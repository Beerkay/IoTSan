/********* Start of macro definitions ******************/
#define MAX_SYSTEM_TIME 50
#define MAX_SUBSCRIBERS 10
#define MAX_ARRAY_SIZE 5
#define MAX_INT_ARRAY_SIZE 5
#define MAX_SWITCH_DEVICES 10
#define MAX_STORED_EVENTS 3
#define MAX_COMMAND_REPITIONS 2
#define MAX_NUM_EVENTS 8
#define ST_SUNRISE_TIME 2
#define ST_SUNSET_TIME 4

/* Int value of string type */
#define MOTION 11
#define ACTIVE 12
#define INACTIVE 13
#define SWITCH 14
#define ON 15
#define OFF 16
#define PRESENCE 17
#define NOT_PRESENT 18
#define PRESENT 19
#define TEMPERATURE 20
#define COOLINGSETPOINT 21
#define COOLINGSETPOINTMIN 22
#define COOLINGSETPOINTMAX 23
#define THERMOSTATFANMODE 24
#define AUTO 25
#define CIRCULATE 26
#define HEATINGSETPOINT 27
#define HEATINGSETPOINTMIN 28
#define HEATINGSETPOINTMAX 29
#define THERMOSTATMODE 30
#define COOL 31
#define EMERGENCY_HEAT 32
#define HEAT 33
#define THERMOSTATOPERATINGSTATE 34
#define COOLING 35
#define FAN_ONLY 36
#define HEATING 37
#define IDLE 38
#define PENDING_COOL 39
#define PENDING_HEAT 40
#define VENT_ECONOMIZER 41
#define THERMOSTATSETPOINT 42
#define THERMOSTATSETPOINTMIN 43
#define THERMOSTATSETPOINTMAX 44
#define LOCK 45
#define LOCKED 46
#define UNKNOWN 47
#define UNLOCKED 48
#define UNLOCKED_WITH_TIMEOUT 49
#define SMOKE 50
#define CLEAR 51
#define DETECTED 52
#define TESTED 53
#define DOOR 54
#define CLOSED 55
#define CLOSING 56
#define OPEN 57
#define OPENING 58
#define CONTACT 59
#define POWER 60
#define ILLUMINANCE 61
#define WATER 62
#define WET 63
#define DRY 64
#define VALVE 65
#define ACCELERATION 66
#define FORECAST 67
#define RAIN 68
#define SNOW 69
#define SHOWERS 70
#define SPRINKLES 71
#define PRECIPITATION 72
#define BATTERY 73
#define LEVEL 74
#define CARBONMONOXIDE 75
#define ALARM 76
#define BOTH 77
#define SIREN 78
#define STROBE 79
#define BUTTON 80
#define PUSHED 81
#define HELD 82
#define COLOR 83
#define HUE 84
#define SATURATION 85
#define HUMIDITY 86
#define POWERED 87
#define MAINS 88
#define DC 89
#define HOME 1400
#define AWAY 1401
#define NIGHT 1402
#define MODE 1403
#define POSITION 1404
#define SUNRISETIME 1405
#define SUNSETTIME 1406
/********* End of macro definitions *******************/

/********* Start of enum definition *******************/
/* mtype defines all attributes' string values (sensor) and commands' names (actuator) */
mtype = {exit, inactive, _active, on, off, notpresent, present, fanAuto, fanCirculate, fanOn,
   Home, Away, Night, _mode, position, _sunrise, _sunset, sunsetTime, sunriseTime, sendSms,
   auto, cool, emergencyHeat, heat, lock, unlock, clear, detected, tested, close, open,
   temperature, appTouch, setCoolingSetpoint, setHeatingSetpoint, put, power_meter,
   illuminance, wet, dry, setLevel, COSmoke, alarm, both, siren, strobe, pushed, held,
   usercodechange, setHue, setSaturation, setColor, tampered, humidity, httpPost, battery,
   powered, mains, dc, unsubscribe};
/********* End of enum definition *********************/

#define type_95 int
#define type_101 bool

typedef int_arr { byte length; short element[MAX_INT_ARRAY_SIZE]; }

typedef STSunriseSunset_rec { 
	type_95 sunrise; 
	type_95 sunset; 
	bool isAlive;
}
typedef STSunriseSunset_arr { byte length; STSunriseSunset_rec element[MAX_ARRAY_SIZE]; }

typedef STWeatherFeature_rec { 
	type_95 forecast; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STWeatherFeature_arr { byte length; STWeatherFeature_rec element[MAX_ARRAY_SIZE]; }

typedef STMode_rec { 
	type_95 name; 
	type_95 id; 
	bool isAlive;
}
typedef STMode_arr { byte length; STMode_rec element[MAX_ARRAY_SIZE]; }

typedef STState_rec { 
	type_95 name; 
	type_95 value; 
	type_95 date; 
	bool isAlive;
}
typedef STState_arr { byte length; STState_rec element[MAX_ARRAY_SIZE]; }

typedef STHub_rec { 
	type_95 localIP; 
	type_95 name; 
	bool isAlive;
}
typedef STHub_arr { byte length; STHub_rec element[MAX_ARRAY_SIZE]; }

typedef STEvent_rec { 
	type_95 name; 
	type_95 value; 
	type_101 physical; 
	type_95 deviceId; 
	type_95 date; 
	type_95 id; 
	type_95 unit; 
	type_101 type; 
	bool isAlive;
	mtype EvtType;
}
typedef STEvent_arr { byte length; STEvent_rec element[MAX_ARRAY_SIZE]; }

typedef STAttribute_rec { 
	type_95 name; 
	bool isAlive;
}
typedef STAttribute_arr { byte length; STAttribute_rec element[MAX_ARRAY_SIZE]; }

typedef STCommand_rec { 
	type_95 name; 
	bool isAlive;
}
typedef STCommand_arr { byte length; STCommand_rec element[MAX_ARRAY_SIZE]; }

typedef STCapability_rec { 
	STAttribute_arr attributes; 
	STCommand_arr commands; 
	type_95 name; 
	bool isAlive;
}
typedef STCapability_arr { byte length; STCapability_rec element[MAX_ARRAY_SIZE]; }

typedef STDevice_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STDevice_arr { byte length; STDevice_rec element[MAX_ARRAY_SIZE]; }

typedef STLocation_rec { 
	type_101 contactBookEnabled; 
	STMode_arr modes; 
	type_95 timeZone; 
	type_95 mode; 
	STSunriseSunset_rec sunriseSunset; 
	STWeatherFeature_rec weatherFeature; 
	STEvent_rec latestEvt; 
	bool isAlive;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STLocation_arr { byte length; STLocation_rec element[MAX_ARRAY_SIZE]; }

typedef STAlarm_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec alarmState; 
	type_95 currentAlarm; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STAlarm_arr { byte length; STAlarm_rec element[MAX_ARRAY_SIZE]; }

typedef STSwitch_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec switchState; 
	type_95 currentSwitch; 
	STState_rec levelState; 
	type_95 currentLevel; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STSwitch_arr { byte length; STSwitch_rec element[MAX_SWITCH_DEVICES]; }

typedef STBulb_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec switchState; 
	type_95 currentSwitch; 
	STState_rec levelState; 
	type_95 currentLevel; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STBulb_arr { byte length; STBulb_rec element[MAX_SWITCH_DEVICES]; }

typedef STTempMeas_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec temperatureState; 
	type_95 currentTemperature; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STTempMeas_arr { byte length; STTempMeas_rec element[MAX_ARRAY_SIZE]; }

typedef STCarDioMeas_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec carbonDioxideState; 
	type_95 currentCarbonDioxide; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STCarDioMeas_arr { byte length; STCarDioMeas_rec element[MAX_ARRAY_SIZE]; }

typedef STCarMoDetector_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec carbonMonoxideState; 
	type_95 currentCarbonMonoxide; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STCarMoDetector_arr { byte length; STCarMoDetector_rec element[MAX_ARRAY_SIZE]; }

typedef STDoorControl_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec doorState; 
	type_95 currentDoor; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STDoorControl_arr { byte length; STDoorControl_rec element[MAX_ARRAY_SIZE]; }

typedef STLight_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec switchState; 
	type_95 currentSwitch; 
	STState_rec levelState; 
	type_95 currentLevel; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STLight_arr { byte length; STLight_rec element[MAX_ARRAY_SIZE]; }

typedef STLock_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec lockState; 
	type_95 currentLock; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STLock_arr { byte length; STLock_rec element[MAX_ARRAY_SIZE]; }

typedef STMotionSensor_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec motionState; 
	type_95 currentMotion; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STMotionSensor_arr { byte length; STMotionSensor_rec element[MAX_ARRAY_SIZE]; }

typedef STPresSensor_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec presenceState; 
	type_95 currentPresence; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STPresSensor_arr { byte length; STPresSensor_rec element[MAX_ARRAY_SIZE]; }

typedef STOutlet_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec switchState; 
	type_95 currentSwitch; 
	STState_rec levelState; 
	type_95 currentLevel; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STOutlet_arr { byte length; STOutlet_rec element[MAX_ARRAY_SIZE]; }

typedef STSmokeDetector_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec carbonMonoxideState; 
	type_95 currentCarbonMonoxide; 
	STState_rec smokeState; 
	type_95 currentSmoke; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STSmokeDetector_arr { byte length; STSmokeDetector_rec element[MAX_ARRAY_SIZE]; }

typedef STTherOpState_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec thermostatOperatingStateState; 
	type_95 currentThermostatOperatingState; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STTherOpState_arr { byte length; STTherOpState_rec element[MAX_ARRAY_SIZE]; }

typedef STTherSetpoint_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec thermostatSetpointState; 
	type_95 currentThermostatSetpoint; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STTherSetpoint_arr { byte length; STTherSetpoint_rec element[MAX_ARRAY_SIZE]; }

typedef STTherMode_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec thermostatModeState; 
	type_95 currentThermostatMode; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STTherMode_arr { byte length; STTherMode_rec element[MAX_ARRAY_SIZE]; }

typedef STTherHeatSetpoint_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec heatingSetpointState; 
	type_95 currentHeatingSetpoint; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STTherHeatSetpoint_arr { byte length; STTherHeatSetpoint_rec element[MAX_ARRAY_SIZE]; }

typedef STTherFanMode_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec thermostatFanModeState; 
	type_95 currentThermostatFanMode; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STTherFanMode_arr { byte length; STTherFanMode_rec element[MAX_ARRAY_SIZE]; }

typedef STTherCoSetpoint_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec coolingSetpointState; 
	type_95 currentCoolingSetpoint; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STTherCoSetpoint_arr { byte length; STTherCoSetpoint_rec element[MAX_ARRAY_SIZE]; }

typedef STThermostat_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec thermostatModeState; 
	type_95 currentThermostatMode; 
	STState_rec temperatureState; 
	type_95 currentTemperature; 
	STState_rec coolingSetpointState; 
	type_95 currentCoolingSetpoint; 
	STState_rec heatingSetpointState; 
	type_95 currentHeatingSetpoint; 
	STState_rec thermostatSetpointState; 
	type_95 currentThermostatSetpoint; 
	STState_rec thermostatFanModeState; 
	type_95 currentThermostatFanMode; 
	STState_rec thermostatOperatingStateState; 
	type_95 currentThermostatOperatingState; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STThermostat_arr { byte length; STThermostat_rec element[MAX_ARRAY_SIZE]; }

typedef STNetworkManager_rec { 
	type_95 configuredPhoneNumber; 
	type_95 receivedPhoneNumber; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STNetworkManager_arr { byte length; STNetworkManager_rec element[MAX_ARRAY_SIZE]; }

typedef STContactSensor_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec contactState; 
	type_95 currentContact; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STContactSensor_arr { byte length; STContactSensor_rec element[MAX_ARRAY_SIZE]; }

typedef CInt2IntMap_rec { 
	type_95 size; 
	int_arr keyArr; 
	int_arr valueArr; 
	type_95 gArrIndex; 
	type_95 keyToPut; 
	type_95 valueToPut; 
	bool isAlive;
}
typedef CInt2IntMap_arr { byte length; CInt2IntMap_rec element[MAX_INT_ARRAY_SIZE]; }

typedef CInt2IIMMap_rec { 
	type_95 size; 
	int_arr keyArr; 
	CInt2IntMap_arr valueArr; 
	type_95 gArrIndex; 
	type_95 keyToPut; 
	CInt2IntMap_rec valueToPut; 
	bool isAlive;
}
typedef CInt2IIMMap_arr { byte length; CInt2IIMMap_rec element[MAX_INT_ARRAY_SIZE]; }

typedef CInt2IIIMMap_rec { 
	type_95 size; 
	int_arr keyArr; 
	CInt2IIMMap_arr valueArr; 
	type_95 gArrIndex; 
	type_95 keyToPut; 
	CInt2IIMMap_rec valueToPut; 
	bool isAlive;
}
typedef CInt2IIIMMap_arr { byte length; CInt2IIIMMap_rec element[MAX_INT_ARRAY_SIZE]; }

typedef STPowerMeter_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec powerState; 
	type_95 currentPower; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STPowerMeter_arr { byte length; STPowerMeter_rec element[MAX_ARRAY_SIZE]; }

typedef STApp_rec { 
	type_95 name; 
	type_95 value; 
	type_95 date; 
	type_95 id; 
	type_95 label; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STApp_arr { byte length; STApp_rec element[MAX_ARRAY_SIZE]; }

typedef STIlMeas_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec illuminanceState; 
	type_95 currentIlluminance; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STIlMeas_arr { byte length; STIlMeas_rec element[MAX_ARRAY_SIZE]; }

typedef STWaterSensor_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec waterState; 
	type_95 currentWater; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STWaterSensor_arr { byte length; STWaterSensor_rec element[MAX_ARRAY_SIZE]; }

typedef STAccSensor_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec accelerationState; 
	type_95 currentAcceleration; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STAccSensor_arr { byte length; STAccSensor_rec element[MAX_ARRAY_SIZE]; }

typedef STSwitchLevel_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec switchState; 
	type_95 currentSwitch; 
	STState_rec levelState; 
	type_95 currentLevel; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STSwitchLevel_arr { byte length; STSwitchLevel_rec element[MAX_ARRAY_SIZE]; }

typedef STValve_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec valveState; 
	type_95 currentValve; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STValve_arr { byte length; STValve_rec element[MAX_ARRAY_SIZE]; }

typedef STAeonKeyFob_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec buttonState; 
	type_95 currentButton; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STAeonKeyFob_arr { byte length; STAeonKeyFob_rec element[MAX_ARRAY_SIZE]; }

typedef STThreeAxis_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec threeAxisState; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STThreeAxis_arr { byte length; STThreeAxis_rec element[MAX_ARRAY_SIZE]; }

typedef STRelHumMeas_rec { 
	type_95 id; 
	type_95 gArrIndex; 
	STEvent_arr events; 
	STState_arr states; 
	STState_rec batteryState; 
	type_95 currentBattery; 
	STState_rec humidityState; 
	type_95 currentHumidity; 
	bool isAlive;
	byte currEvtIndex;
	byte BroadcastChanIndex;
	byte NumReceivedCommands;
	byte NumSubscribers;
	bool BroadcastChans[MAX_SUBSCRIBERS];
	bool isOnline;
}
typedef STRelHumMeas_arr { byte length; STRelHumMeas_rec element[MAX_ARRAY_SIZE]; }


/*************** Start of devices declaration ****************/
hidden byte doorLock_STLock;
hidden byte frontDoorSensor_STMotionSensor;
hidden byte livingRoomBulb_STSwitch;
hidden byte bedRoomBulb_STSwitch;
hidden byte livingRoomSensor_STMotionSensor;
hidden byte bedRoomSensor_STMotionSensor;
hidden byte bedRoomDoor_STContactSensor;

STLock_arr _g_STLockArr;
STMotionSensor_arr _g_STMotionSensorArr;
STSwitch_arr _g_STSwitchArr;
STContactSensor_arr _g_STContactSensorArr;

byte STCurrentSystemTime;
byte STCurrentTemperature;
STNetworkManager_rec _STNetworkManager;
bool httpPostAllowed = false;
STLocation_rec location;
hidden byte UnlockDoor_location; /* location's broadcast channel index */
hidden byte GoodNight_location; /* location's broadcast channel index */
/*************** End of devices declaration ******************/

/*************** Start of global variables of smart apps *****/
hidden STApp_rec GoodNight_app;   
hidden STMotionSensor_arr GoodNight_motionSensors;   
hidden type_95 GoodNight_minutes;   
hidden type_95 GoodNight_timeOfDay;   
hidden STSwitch_arr GoodNight_switches;   
hidden type_95 GoodNight_newMode;   
hidden type_95 GoodNight_recipients;   
hidden type_95 GoodNight_sendPushMessage;   
hidden type_95 GoodNight_phoneNumber;   
hidden type_95 GoodNight_modeStartTime;   
hidden STApp_rec LightFollowsMe_app;   
hidden STMotionSensor_rec LightFollowsMe_motion1;   
hidden type_95 LightFollowsMe_minutes1;   
hidden STSwitch_arr LightFollowsMe_switches;   
hidden STApp_rec UnlockDoor_app;   
hidden STLock_arr UnlockDoor_locks;   
hidden STApp_rec LightOffWhenClosed_app;   
hidden STContactSensor_rec LightOffWhenClosed_contact1;   
hidden STSwitch_rec LightOffWhenClosed_switch1;   
/*************** End of global variables of smart apps *******/

/*************** Start of assignment methods *****************/
hidden short _index;
hidden short i;
hidden short i0;
hidden short i1;
hidden short i2;
hidden short i3;
hidden short i4;
hidden short i5;
hidden short i6;
hidden short i7;
hidden short i8;
hidden short i9;
hidden short i10;
hidden short i11;
hidden short i12;
hidden short i13;
hidden short i14;
hidden short i15;
hidden short i16;
hidden short i17;
hidden short i18;
hidden short i19;
hidden short i20;
hidden short i21;
hidden short i22;
hidden short i23;
hidden short i24;
hidden short i25;
hidden short i26;
hidden short i27;
hidden short i28;
hidden short i29;
hidden short i30;
hidden short i31;
hidden short i32;
hidden short i33;
hidden short i34;
hidden short i35;
hidden short i36;
hidden short i37;
hidden short i38;
hidden short i39;
hidden short i40;
hidden short i41;
hidden short i42;

inline assign_STSunriseSunset_rec(rec1, rec2)
{
   rec1.sunrise = rec2.sunrise;
   rec1.sunset = rec2.sunset;
   rec1.isAlive = rec2.isAlive;
}
inline assign_STWeatherFeature_rec(rec1, rec2)
{
   rec1.forecast = rec2.forecast;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STMode_rec(rec1, rec2)
{
   rec1.name = rec2.name;
   rec1.id = rec2.id;
   rec1.isAlive = rec2.isAlive;
}
inline assign_STState_rec(rec1, rec2)
{
   rec1.name = rec2.name;
   rec1.value = rec2.value;
   rec1.date = rec2.date;
   rec1.isAlive = rec2.isAlive;
}
inline assign_STHub_rec(rec1, rec2)
{
   rec1.localIP = rec2.localIP;
   rec1.name = rec2.name;
   rec1.isAlive = rec2.isAlive;
}
inline assign_STEvent_rec(rec1, rec2)
{
   rec1.name = rec2.name;
   rec1.value = rec2.value;
   rec1.physical = rec2.physical;
   rec1.deviceId = rec2.deviceId;
   rec1.date = rec2.date;
   rec1.id = rec2.id;
   rec1.unit = rec2.unit;
   rec1.type = rec2.type;
   rec1.isAlive = rec2.isAlive;
   rec1.EvtType = rec2.EvtType;
}
inline assign_STAttribute_rec(rec1, rec2)
{
   rec1.name = rec2.name;
   rec1.isAlive = rec2.isAlive;
}
inline assign_STCommand_rec(rec1, rec2)
{
   rec1.name = rec2.name;
   rec1.isAlive = rec2.isAlive;
}
inline assign_STCapability_rec(rec1, rec2)
{
   assign_STAttribute_arr(rec1.attributes, rec2.attributes);
   assign_STCommand_arr(rec1.commands, rec2.commands);
   rec1.name = rec2.name;
   rec1.isAlive = rec2.isAlive;
}
inline assign_STDevice_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STLocation_rec(rec1, rec2)
{
   rec1.contactBookEnabled = rec2.contactBookEnabled;
   assign_STMode_arr(rec1.modes, rec2.modes);
   rec1.timeZone = rec2.timeZone;
   rec1.mode = rec2.mode;
   assign_STSunriseSunset_rec(rec1.sunriseSunset, rec2.sunriseSunset);
   assign_STWeatherFeature_rec(rec1.weatherFeature, rec2.weatherFeature);
   assign_STEvent_rec(rec1.latestEvt, rec2.latestEvt);
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.LatestCommandType = rec2.LatestCommandType;
   rec1.LatestCommandID = rec2.LatestCommandID;
}
inline assign_STAlarm_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.alarmState, rec2.alarmState);
   rec1.currentAlarm = rec2.currentAlarm;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STSwitch_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.switchState, rec2.switchState);
   rec1.currentSwitch = rec2.currentSwitch;
   assign_STState_rec(rec1.levelState, rec2.levelState);
   rec1.currentLevel = rec2.currentLevel;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STBulb_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.switchState, rec2.switchState);
   rec1.currentSwitch = rec2.currentSwitch;
   assign_STState_rec(rec1.levelState, rec2.levelState);
   rec1.currentLevel = rec2.currentLevel;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STTempMeas_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.temperatureState, rec2.temperatureState);
   rec1.currentTemperature = rec2.currentTemperature;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STCarDioMeas_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.carbonDioxideState, rec2.carbonDioxideState);
   rec1.currentCarbonDioxide = rec2.currentCarbonDioxide;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STCarMoDetector_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.carbonMonoxideState, rec2.carbonMonoxideState);
   rec1.currentCarbonMonoxide = rec2.currentCarbonMonoxide;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STDoorControl_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.doorState, rec2.doorState);
   rec1.currentDoor = rec2.currentDoor;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STLight_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.switchState, rec2.switchState);
   rec1.currentSwitch = rec2.currentSwitch;
   assign_STState_rec(rec1.levelState, rec2.levelState);
   rec1.currentLevel = rec2.currentLevel;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STLock_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.lockState, rec2.lockState);
   rec1.currentLock = rec2.currentLock;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STMotionSensor_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.motionState, rec2.motionState);
   rec1.currentMotion = rec2.currentMotion;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STPresSensor_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.presenceState, rec2.presenceState);
   rec1.currentPresence = rec2.currentPresence;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STOutlet_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.switchState, rec2.switchState);
   rec1.currentSwitch = rec2.currentSwitch;
   assign_STState_rec(rec1.levelState, rec2.levelState);
   rec1.currentLevel = rec2.currentLevel;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STSmokeDetector_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.carbonMonoxideState, rec2.carbonMonoxideState);
   rec1.currentCarbonMonoxide = rec2.currentCarbonMonoxide;
   assign_STState_rec(rec1.smokeState, rec2.smokeState);
   rec1.currentSmoke = rec2.currentSmoke;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STTherOpState_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.thermostatOperatingStateState, rec2.thermostatOperatingStateState);
   rec1.currentThermostatOperatingState = rec2.currentThermostatOperatingState;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STTherSetpoint_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.thermostatSetpointState, rec2.thermostatSetpointState);
   rec1.currentThermostatSetpoint = rec2.currentThermostatSetpoint;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STTherMode_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.thermostatModeState, rec2.thermostatModeState);
   rec1.currentThermostatMode = rec2.currentThermostatMode;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STTherHeatSetpoint_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.heatingSetpointState, rec2.heatingSetpointState);
   rec1.currentHeatingSetpoint = rec2.currentHeatingSetpoint;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STTherFanMode_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.thermostatFanModeState, rec2.thermostatFanModeState);
   rec1.currentThermostatFanMode = rec2.currentThermostatFanMode;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STTherCoSetpoint_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.coolingSetpointState, rec2.coolingSetpointState);
   rec1.currentCoolingSetpoint = rec2.currentCoolingSetpoint;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STThermostat_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.thermostatModeState, rec2.thermostatModeState);
   rec1.currentThermostatMode = rec2.currentThermostatMode;
   assign_STState_rec(rec1.temperatureState, rec2.temperatureState);
   rec1.currentTemperature = rec2.currentTemperature;
   assign_STState_rec(rec1.coolingSetpointState, rec2.coolingSetpointState);
   rec1.currentCoolingSetpoint = rec2.currentCoolingSetpoint;
   assign_STState_rec(rec1.heatingSetpointState, rec2.heatingSetpointState);
   rec1.currentHeatingSetpoint = rec2.currentHeatingSetpoint;
   assign_STState_rec(rec1.thermostatSetpointState, rec2.thermostatSetpointState);
   rec1.currentThermostatSetpoint = rec2.currentThermostatSetpoint;
   assign_STState_rec(rec1.thermostatFanModeState, rec2.thermostatFanModeState);
   rec1.currentThermostatFanMode = rec2.currentThermostatFanMode;
   assign_STState_rec(rec1.thermostatOperatingStateState, rec2.thermostatOperatingStateState);
   rec1.currentThermostatOperatingState = rec2.currentThermostatOperatingState;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STNetworkManager_rec(rec1, rec2)
{
   rec1.configuredPhoneNumber = rec2.configuredPhoneNumber;
   rec1.receivedPhoneNumber = rec2.receivedPhoneNumber;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STContactSensor_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.contactState, rec2.contactState);
   rec1.currentContact = rec2.currentContact;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STPowerMeter_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.powerState, rec2.powerState);
   rec1.currentPower = rec2.currentPower;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STApp_rec(rec1, rec2)
{
   rec1.name = rec2.name;
   rec1.value = rec2.value;
   rec1.date = rec2.date;
   rec1.id = rec2.id;
   rec1.label = rec2.label;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STIlMeas_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.illuminanceState, rec2.illuminanceState);
   rec1.currentIlluminance = rec2.currentIlluminance;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STWaterSensor_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.waterState, rec2.waterState);
   rec1.currentWater = rec2.currentWater;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STAccSensor_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.accelerationState, rec2.accelerationState);
   rec1.currentAcceleration = rec2.currentAcceleration;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STSwitchLevel_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.switchState, rec2.switchState);
   rec1.currentSwitch = rec2.currentSwitch;
   assign_STState_rec(rec1.levelState, rec2.levelState);
   rec1.currentLevel = rec2.currentLevel;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STValve_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.valveState, rec2.valveState);
   rec1.currentValve = rec2.currentValve;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STAeonKeyFob_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.buttonState, rec2.buttonState);
   rec1.currentButton = rec2.currentButton;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STThreeAxis_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.threeAxisState, rec2.threeAxisState);
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STRelHumMeas_rec(rec1, rec2)
{
   rec1.id = rec2.id;
   rec1.gArrIndex = rec2.gArrIndex;
   assign_STEvent_arr(rec1.events, rec2.events);
   assign_STState_arr(rec1.states, rec2.states);
   assign_STState_rec(rec1.batteryState, rec2.batteryState);
   rec1.currentBattery = rec2.currentBattery;
   assign_STState_rec(rec1.humidityState, rec2.humidityState);
   rec1.currentHumidity = rec2.currentHumidity;
   rec1.isAlive = rec2.isAlive;
   rec1.NumReceivedCommands = rec2.NumReceivedCommands;
   rec1.currEvtIndex = rec2.currEvtIndex;
}
inline assign_STSunriseSunset_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i0 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STSunriseSunset_rec(arr1.element[i0], arr2.element[i0]);
   }
}
inline assign_STWeatherFeature_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i1 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STWeatherFeature_rec(arr1.element[i1], arr2.element[i1]);
   }
}
inline assign_STMode_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i2 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STMode_rec(arr1.element[i2], arr2.element[i2]);
   }
}
inline assign_STState_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i3 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STState_rec(arr1.element[i3], arr2.element[i3]);
   }
}
inline assign_STHub_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i4 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STHub_rec(arr1.element[i4], arr2.element[i4]);
   }
}
inline assign_STLocation_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i5 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STLocation_rec(arr1.element[i5], arr2.element[i5]);
   }
}
inline assign_STAttribute_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i6 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STAttribute_rec(arr1.element[i6], arr2.element[i6]);
   }
}
inline assign_STCommand_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i7 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STCommand_rec(arr1.element[i7], arr2.element[i7]);
   }
}
inline assign_STCapability_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i8 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STCapability_rec(arr1.element[i8], arr2.element[i8]);
   }
}
inline assign_STDevice_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i9 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STDevice_rec(arr1.element[i9], arr2.element[i9]);
   }
}
inline assign_STEvent_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i10 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STEvent_rec(arr1.element[i10], arr2.element[i10]);
   }
}
inline assign_STAlarm_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i11 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STAlarm_rec(arr1.element[i11], arr2.element[i11]);
   }
}
inline assign_STSwitch_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i12 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STSwitch_rec(arr1.element[i12], arr2.element[i12]);
   }
}
inline assign_STBulb_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i13 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STBulb_rec(arr1.element[i13], arr2.element[i13]);
   }
}
inline assign_STTempMeas_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i14 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STTempMeas_rec(arr1.element[i14], arr2.element[i14]);
   }
}
inline assign_STCarDioMeas_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i15 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STCarDioMeas_rec(arr1.element[i15], arr2.element[i15]);
   }
}
inline assign_STCarMoDetector_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i16 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STCarMoDetector_rec(arr1.element[i16], arr2.element[i16]);
   }
}
inline assign_STDoorControl_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i17 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STDoorControl_rec(arr1.element[i17], arr2.element[i17]);
   }
}
inline assign_STLight_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i18 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STLight_rec(arr1.element[i18], arr2.element[i18]);
   }
}
inline assign_STLock_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i19 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STLock_rec(arr1.element[i19], arr2.element[i19]);
   }
}
inline assign_STMotionSensor_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i20 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STMotionSensor_rec(arr1.element[i20], arr2.element[i20]);
   }
}
inline assign_STPresSensor_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i21 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STPresSensor_rec(arr1.element[i21], arr2.element[i21]);
   }
}
inline assign_STOutlet_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i22 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STOutlet_rec(arr1.element[i22], arr2.element[i22]);
   }
}
inline assign_STSmokeDetector_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i23 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STSmokeDetector_rec(arr1.element[i23], arr2.element[i23]);
   }
}
inline assign_STTherOpState_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i24 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STTherOpState_rec(arr1.element[i24], arr2.element[i24]);
   }
}
inline assign_STTherSetpoint_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i25 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STTherSetpoint_rec(arr1.element[i25], arr2.element[i25]);
   }
}
inline assign_STTherMode_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i26 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STTherMode_rec(arr1.element[i26], arr2.element[i26]);
   }
}
inline assign_STTherHeatSetpoint_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i27 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STTherHeatSetpoint_rec(arr1.element[i27], arr2.element[i27]);
   }
}
inline assign_STTherFanMode_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i28 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STTherFanMode_rec(arr1.element[i28], arr2.element[i28]);
   }
}
inline assign_STTherCoSetpoint_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i29 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STTherCoSetpoint_rec(arr1.element[i29], arr2.element[i29]);
   }
}
inline assign_STThermostat_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i30 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STThermostat_rec(arr1.element[i30], arr2.element[i30]);
   }
}
inline assign_STNetworkManager_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i31 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STNetworkManager_rec(arr1.element[i31], arr2.element[i31]);
   }
}
inline assign_STContactSensor_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i32 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STContactSensor_rec(arr1.element[i32], arr2.element[i32]);
   }
}
inline assign_STPowerMeter_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i33 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STPowerMeter_rec(arr1.element[i33], arr2.element[i33]);
   }
}
inline assign_STApp_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i34 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STApp_rec(arr1.element[i34], arr2.element[i34]);
   }
}
inline assign_STIlMeas_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i35 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STIlMeas_rec(arr1.element[i35], arr2.element[i35]);
   }
}
inline assign_STWaterSensor_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i36 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STWaterSensor_rec(arr1.element[i36], arr2.element[i36]);
   }
}
inline assign_STAccSensor_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i37 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STAccSensor_rec(arr1.element[i37], arr2.element[i37]);
   }
}
inline assign_STSwitchLevel_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i38 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STSwitchLevel_rec(arr1.element[i38], arr2.element[i38]);
   }
}
inline assign_STValve_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i39 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STValve_rec(arr1.element[i39], arr2.element[i39]);
   }
}
inline assign_STAeonKeyFob_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i40 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STAeonKeyFob_rec(arr1.element[i40], arr2.element[i40]);
   }
}
inline assign_STThreeAxis_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i41 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STThreeAxis_rec(arr1.element[i41], arr2.element[i41]);
   }
}
inline assign_STRelHumMeas_arr(arr1, arr2)
{
   arr1.length = arr2.length;
   for(i42 : 0 .. MAX_ARRAY_SIZE-1) {
      assign_STRelHumMeas_rec(arr1.element[i42], arr2.element[i42]);
   }
}
inline assign_int_arr(arr1, arr2)
{
	arr1.length = arr2.length;
	for(i0 : 0 .. MAX_INT_ARRAY_SIZE-1) {
		arr1.element[i0] = arr2.element[i0];
	}
}
/*************** End of assignment methods *******************/

/*************** Start of event handler inline methods *******/
inline GoodNight_installedEvtHandler(evt) {
   STEvent_rec _ST_Command;

   /* Default initialization */
   d_step {
      _ST_Command.id = evt.id;
      _ST_Command.physical = 0;
   }
loc_4:
   atomic { 
      skip;
      d_step {
         skip;
      }
      skip;
      goto loc_5;
   }
loc_5:
   if
   :: atomic { 
         (GoodNight_modeStartTime != 0)-> 
         goto loc_6;
      }
   :: atomic { 
         (! (GoodNight_modeStartTime != 0))-> 
         goto loc_9;
      }
   fi;
loc_6:
   atomic { 
      skip;
      d_step {
         skip;
      }
      skip;
      goto loc_8;
   }
loc_8:
   goto done;
loc_9:
   atomic { 
      skip;
      d_step {
         GoodNight_modeStartTime = 0;
      }
      skip;
      goto loc_6;
   }
done: skip;
}

hidden STMotionSensor_rec m4_it;   
hidden STState_rec m4_m5_0__ret;   
hidden STState_rec m4_findResult1;   
hidden STState_rec m4_it_0;   
hidden STState_arr m4_states;   
hidden STState_arr m4_collectResult1;   
hidden STMotionSensor_rec m4_m5_0_JJJCTEMP_0;   
hidden STSwitch_rec m6_it;   
hidden STState_rec m4_sensor;   
inline GoodNight_switchOffEvtHandler(evt) {
   type_95 m4_threshold;   
   type_95 m6_result;   
   type_95 m1_modeStartTime;   
   type_95 m4_elapsed;   
   type_95 m4_m5_0_attributeName;   
   type_95 m1_m2__ret;   
   type_95 m0__ret;   
   type_95 m1_m3_timeVal;   
   type_95 m4_index6;   
   type_95 m4_index5;   
   type_95 m4__ret;   
   type_95 m6__ret;   
   type_95 m6_index4;   
   type_95 m4_m2__ret;   
   type_95 m1_m3_timeZone;   
   type_95 m1_m3_startTime;   
   type_95 m7_m8_mode;   
   type_95 m1_t0;   
   type_95 m1_m3__ret;   
   type_95 m1_startTime;   
   type_95 m1__ret;   
   type_95 m4_JJJCTEMP_9;   
   STEvent_rec _ST_Command;

   /* Default initialization */
   d_step {
      m4_it.isAlive = 0;
      m4_m5_0__ret.isAlive = 0;
      m4_findResult1.isAlive = 0;
      m4_it_0.isAlive = 0;
      m4_states.length = 0;
      m4_collectResult1.length = 0;
      m4_m5_0_JJJCTEMP_0.isAlive = 0;
      m6_it.isAlive = 0;
      m4_sensor.isAlive = 0;
      _ST_Command.id = evt.id;
      _ST_Command.physical = 0;
   }
loc_13:
   atomic { 
      skip;
      d_step {
         skip;
      }
      skip;
      goto loc_14;
   }
loc_14:
   if
   :: atomic { 
         (location.mode == GoodNight_newMode)-> 
         goto loc_15;
      }
   :: atomic { 
         (! (location.mode == GoodNight_newMode))-> 
         goto loc_129;
      }
   fi;
loc_15:
   atomic { 
      skip;
      d_step {
         m0__ret = 0;
         m4_threshold = m0__ret;
      }
      skip;
      goto loc_18;
   }
loc_18:
   atomic { 
      skip;
      d_step {
         skip;
      }
      skip;
      goto loc_19;
   }
loc_19:
   if
   :: atomic { 
         (m4_threshold == 0)-> 
         goto loc_20;
      }
   :: atomic { 
         (! (m4_threshold == 0))-> 
         goto loc_21;
      }
   fi;
loc_20:
   goto done;
loc_21:
   atomic { 
      skip;
      d_step {
         m1_m2__ret = (STCurrentSystemTime * 3600000);
         m1_t0 = m1_m2__ret;
         m1_m2__ret = (STCurrentSystemTime * 3600000);
         m1_modeStartTime = m1_m2__ret;
         m1_m3_startTime = m1_modeStartTime;
         m1_m3_timeVal = GoodNight_timeOfDay;
         m1_m3_timeZone = location.timeZone;
         m1_m3__ret = (m1_m3_timeVal * 3600000);
         m1_startTime = m1_m3__ret;
      }
      skip;
      goto loc_37;
   }
loc_37:
   if
   :: atomic { 
         (m1_t0 < m1_startTime)-> 
         goto loc_38;
      }
   :: atomic { 
         (! (m1_t0 < m1_startTime))-> 
         goto loc_126;
      }
   fi;
loc_38:
   atomic { 
      skip;
      d_step {
         m1__ret = 0;
         m4_threshold = m1__ret;
      }
      skip;
      goto loc_41;
   }
loc_41:
   atomic { 
      skip;
      d_step {
         skip;
      }
      skip;
      goto loc_42;
   }
loc_42:
   if
   :: atomic { 
         (m4_threshold == 0)-> 
         goto loc_20;
      }
   :: atomic { 
         (! (m4_threshold == 0))-> 
         goto loc_43;
      }
   fi;
loc_43:
   atomic { 
      skip;
      d_step {
         m4_threshold = (1000 * 60);
         m4_threshold = (m4_threshold * GoodNight_minutes);
         m4_threshold = (m4_threshold - 1000);
         m4_index5 = 0;
      }
      skip;
      goto loc_49;
   }
loc_49:
   atomic { 
      skip;
      d_step {
         m4_JJJCTEMP_9 = GoodNight_motionSensors.length;
      }
      skip;
      goto loc_50;
   }
loc_50:
   if
   :: atomic { 
         (m4_index5 < m4_JJJCTEMP_9)-> 
         goto loc_51;
      }
   :: atomic { 
         (! (m4_index5 < m4_JJJCTEMP_9))-> 
         goto loc_60;
      }
   fi;
loc_51:
   atomic { 
      skip;
      d_step {
         assign_STMotionSensor_rec(m4_it, GoodNight_motionSensors.element[m4_index5]);
         assign_STMotionSensor_rec(m4_m5_0_JJJCTEMP_0, m4_it);
         m4_m5_0_attributeName = 11;
         assign_STState_rec(m4_m5_0__ret, m4_m5_0_JJJCTEMP_0.motionState);
         assign_STState_rec(m4_m5_0__ret, m4_m5_0__ret);
         m4_collectResult1.length++;
         assign_STState_rec(m4_collectResult1.element[m4_index5], m4_m5_0__ret);
         m4_index5 = (m4_index5 + 1);
      }
      skip;
      goto loc_49;
   }
loc_60:
   atomic { 
      skip;
      d_step {
         assign_STState_arr(m4_states, m4_collectResult1);
      }
      skip;
      goto loc_61;
   }
loc_61:
   if
   :: atomic { 
         (m4_states.length == 0)-> 
         goto loc_62;
      }
   :: atomic { 
         (! (m4_states.length == 0))-> 
         goto loc_99;
      }
   fi;
loc_62:
   atomic { 
      skip;
      d_step {
         m4__ret = 1;
         m4_threshold = m4__ret;
      }
      skip;
      goto loc_65;
   }
loc_65:
   atomic { 
      skip;
      d_step {
         skip;
      }
      skip;
      goto loc_66;
   }
loc_66:
   if
   :: atomic { 
         (m4_threshold == 0)-> 
         goto loc_20;
      }
   :: atomic { 
         (! (m4_threshold == 0))-> 
         goto loc_67;
      }
   fi;
loc_67:
   atomic { 
      skip;
      d_step {
         m6_result = 1;
         m6_index4 = 0;
      }
      skip;
      goto loc_72;
   }
loc_72:
   atomic { 
      skip;
      d_step {
         m4_JJJCTEMP_9 = GoodNight_switches.length;
      }
      skip;
      goto loc_73;
   }
loc_73:
   if
   :: atomic { 
         (m6_index4 < m4_JJJCTEMP_9)-> 
         goto loc_74;
      }
   :: atomic { 
         (! (m6_index4 < m4_JJJCTEMP_9))-> 
         goto loc_80;
      }
   fi;
loc_74:
   atomic { 
      skip;
      d_step {
         assign_STSwitch_rec(m6_it, GoodNight_switches.element[m6_index4]);
         m4_JJJCTEMP_9 = m6_it.currentSwitch;
      }
      skip;
      goto loc_76;
   }
loc_76:
   if
   :: atomic { 
         (m4_JJJCTEMP_9 != 15)-> 
         goto loc_77;
      }
   :: atomic { 
         (! (m4_JJJCTEMP_9 != 15))-> 
         goto loc_78;
      }
   fi;
loc_77:
   atomic { 
      skip;
      d_step {
         m6_index4 = (m6_index4 + 1);
      }
      skip;
      goto loc_72;
   }
loc_78:
   atomic { 
      skip;
      d_step {
         m6_result = 0;
      }
      skip;
      goto loc_80;
   }
loc_80:
   atomic { 
      skip;
      d_step {
         m6__ret = m6_result;
         m4_threshold = m6__ret;
      }
      skip;
      goto loc_84;
   }
loc_84:
   if
   :: atomic { 
         (m4_threshold == 0)-> 
         goto loc_20;
      }
   :: atomic { 
         (! (m4_threshold == 0))-> 
         goto loc_85;
      }
   fi;
loc_85:
   atomic { 
      skip;
      d_step {
         m7_m8_mode = GoodNight_newMode;
      }
      skip;
      goto loc_87;
   }
loc_87:
   if
   :: atomic { 
         (m7_m8_mode != 1400)-> 
         goto loc_88;
      }
   :: atomic { 
         (! (m7_m8_mode != 1400))-> 
         goto loc_97;
      }
   fi;
loc_88:
   if
   :: atomic { 
         (m7_m8_mode != 1401)-> 
         goto loc_89;
      }
   :: atomic { 
         (! (m7_m8_mode != 1401))-> 
         goto loc_95;
      }
   fi;
loc_89:
   if
   :: atomic { 
         (m7_m8_mode != 1402)-> 
         goto loc_90;
      }
   :: atomic { 
         (! (m7_m8_mode != 1402))-> 
         goto loc_94;
      }
   fi;
loc_90:
   atomic { 
      skip;
      d_step {
         skip;
      }
      skip;
      goto loc_20;
   }
loc_94:
   atomic { 
      skip;
      d_step {
         _ST_Command.EvtType = Night;
         HandleLocationEvt(_ST_Command);
      }
      skip;
      goto loc_90;
   }
loc_95:
   atomic { 
      skip;
      d_step {
         _ST_Command.EvtType = Away;
         HandleLocationEvt(_ST_Command);
      }
      skip;
      goto loc_90;
   }
loc_97:
   atomic { 
      skip;
      d_step {
         _ST_Command.EvtType = Home;
         HandleLocationEvt(_ST_Command);
      }
      skip;
      goto loc_90;
   }
loc_99:
   atomic { 
      skip;
      d_step {
         m4_index6 = 0;
      }
      skip;
      goto loc_101;
   }
loc_101:
   atomic { 
      skip;
      d_step {
         m4_JJJCTEMP_9 = m4_states.length;
      }
      skip;
      goto loc_102;
   }
loc_102:
   if
   :: atomic { 
         (m4_index6 < m4_JJJCTEMP_9)-> 
         goto loc_103;
      }
   :: atomic { 
         (! (m4_index6 < m4_JJJCTEMP_9))-> 
         goto loc_108;
      }
   fi;
loc_103:
   atomic { 
      skip;
      d_step {
         assign_STState_rec(m4_it_0, m4_states.element[m4_index6]);
         m4_JJJCTEMP_9 = m4_it_0.value;
      }
      skip;
      goto loc_105;
   }
loc_105:
   if
   :: atomic { 
         (m4_JJJCTEMP_9 != 12)-> 
         goto loc_106;
      }
   :: atomic { 
         (! (m4_JJJCTEMP_9 != 12))-> 
         goto loc_107;
      }
   fi;
loc_106:
   atomic { 
      skip;
      d_step {
         m4_index6 = (m4_index6 + 1);
      }
      skip;
      goto loc_101;
   }
loc_107:
   atomic { 
      skip;
      d_step {
         assign_STState_rec(m4_findResult1, m4_it_0);
      }
      skip;
      goto loc_106;
   }
loc_108:
   if
   :: atomic { 
         (m4_findResult1.isAlive == 0)-> 
         goto loc_109;
      }
   :: atomic { 
         (! (m4_findResult1.isAlive == 0))-> 
         goto loc_123;
      }
   fi;
loc_109:
   atomic { 
      skip;
      d_step {
         assign_STState_rec(m4_sensor, m4_states.element[0]);
         m4_m2__ret = (STCurrentSystemTime * 3600000);
         m4_JJJCTEMP_9 = m4_m2__ret;
         m1_m3_timeVal = m4_sensor.date;
         m4_elapsed = (m4_JJJCTEMP_9 - m1_m3_timeVal);
      }
      skip;
      goto loc_116;
   }
loc_116:
   if
   :: atomic { 
         (m4_elapsed < m4_threshold)-> 
         goto loc_117;
      }
   :: atomic { 
         (! (m4_elapsed < m4_threshold))-> 
         goto loc_120;
      }
   fi;
loc_117:
   atomic { 
      skip;
      d_step {
         m4__ret = 0;
         m4_threshold = m4__ret;
      }
      skip;
      goto loc_65;
   }
loc_120:
   atomic { 
      skip;
      d_step {
         m4__ret = 1;
         m4_threshold = m4__ret;
      }
      skip;
      goto loc_65;
   }
loc_123:
   atomic { 
      skip;
      d_step {
         m4__ret = 0;
         m4_threshold = m4__ret;
      }
      skip;
      goto loc_65;
   }
loc_126:
   atomic { 
      skip;
      d_step {
         m1__ret = 1;
         m4_threshold = m1__ret;
      }
      skip;
      goto loc_41;
   }
loc_129:
   atomic { 
      skip;
      d_step {
         m0__ret = 1;
         m4_threshold = m0__ret;
      }
      skip;
      goto loc_18;
   }
done: skip;
}

hidden STState_rec m10_1_m4_m5_1__ret;   
hidden STMotionSensor_rec m10_1_m4_it;   
hidden STSwitch_rec m10_1_m6_it;   
hidden STState_rec m10_1_m4_it_0;   
hidden STState_rec m10_1_m4_sensor;   
hidden STState_rec m10_1_m4_findResult1;   
hidden STMotionSensor_rec m10_1_m4_m5_1_JJJCTEMP_0;   
hidden STState_arr m10_1_m4_collectResult1;   
hidden STState_arr m10_1_m4_states;   
inline GoodNight_motionInactiveEvtHandler(evt) {
   type_95 m10_1_m1__ret;   
   type_95 m1_startTime_0;   
   type_95 m1_m3_startTime_0;   
   type_95 m9_amount;   
   type_95 m1_m3_timeZone_0;   
   type_95 m9_h;   
   type_95 m10_1_m4_m2__ret;   
   type_95 m10_1_m1_m3_timeVal;   
   type_95 m9_JJJCTEMP_0;   
   type_95 m10_1_m4_elapsed;   
   type_95 m10_1_m1_startTime;   
   type_95 m10_1_m1_m3_timeZone;   
   type_95 m10_1_m1_m3_startTime;   
   type_95 m10_1_m6_result;   
   type_95 m10_1_m4__ret;   
   type_95 m0__ret_0;   
   type_95 m10_1_m1_t0;   
   type_95 m10_1_m4_m5_1_attributeName;   
   type_95 m10_1_m1_modeStartTime;   
   type_95 m10_1_m7_m8_mode;   
   type_95 m1_t0_0;   
   type_95 m10_1_m1_m2__ret;   
   type_95 m1__ret_0;   
   type_95 m10_1_m6__ret;   
   type_95 m1_m2__ret_0;   
   type_95 m10_1_m6_index4;   
   type_95 m10_1_m1_m3__ret;   
   type_95 m10_1_m0__ret;   
   type_95 m10_1_m4_threshold;   
   type_95 m10_1_m4_index6;   
   type_95 m10_1_m4_index5;   
   type_95 m1_m3_timeVal_0;   
   type_95 m1_m3__ret_0;   
   type_95 m1_modeStartTime_0;   
   STEvent_rec _ST_Command;

   /* Default initialization */
   d_step {
      m10_1_m4_m5_1__ret.isAlive = 0;
      m10_1_m4_it.isAlive = 0;
      m10_1_m6_it.isAlive = 0;
      m10_1_m4_it_0.isAlive = 0;
      m10_1_m4_sensor.isAlive = 0;
      m10_1_m4_findResult1.isAlive = 0;
      m10_1_m4_m5_1_JJJCTEMP_0.isAlive = 0;
      m10_1_m4_collectResult1.length = 0;
      m10_1_m4_states.length = 0;
      _ST_Command.id = evt.id;
      _ST_Command.physical = 0;
   }
loc_133:
   if
   :: atomic { 
         (GoodNight_modeStartTime != 0)-> 
         goto loc_134;
      }
   :: atomic { 
         (! (GoodNight_modeStartTime != 0))-> 
         goto loc_300;
      }
   fi;
loc_134:
   atomic { 
      skip;
      d_step {
         skip;
      }
      skip;
      goto loc_135;
   }
loc_135:
   if
   :: atomic { 
         (location.mode == GoodNight_newMode)-> 
         goto loc_136;
      }
   :: atomic { 
         (! (location.mode == GoodNight_newMode))-> 
         goto loc_297;
      }
   fi;
loc_136:
   atomic { 
      skip;
      d_step {
         m0__ret_0 = 0;
         m9_h = m0__ret_0;
      }
      skip;
      goto loc_139;
   }
loc_139:
   atomic { 
      skip;
      d_step {
         skip;
      }
      skip;
      goto loc_140;
   }
loc_140:
   if
   :: atomic { 
         (m9_h == 0)-> 
         goto loc_141;
      }
   :: atomic { 
         (! (m9_h == 0))-> 
         goto loc_142;
      }
   fi;
loc_141:
   goto done;
loc_142:
   atomic { 
      skip;
      d_step {
         m1_m2__ret_0 = (STCurrentSystemTime * 3600000);
         m1_t0_0 = m1_m2__ret_0;
         m1_m2__ret_0 = (STCurrentSystemTime * 3600000);
         m1_modeStartTime_0 = m1_m2__ret_0;
         m1_m3_startTime_0 = m1_modeStartTime_0;
         m1_m3_timeVal_0 = GoodNight_timeOfDay;
         m1_m3_timeZone_0 = location.timeZone;
         m1_m3__ret_0 = (m1_m3_timeVal_0 * 3600000);
         m1_startTime_0 = m1_m3__ret_0;
      }
      skip;
      goto loc_158;
   }
loc_158:
   if
   :: atomic { 
         (m1_t0_0 < m1_startTime_0)-> 
         goto loc_159;
      }
   :: atomic { 
         (! (m1_t0_0 < m1_startTime_0))-> 
         goto loc_294;
      }
   fi;
loc_159:
   atomic { 
      skip;
      d_step {
         m1__ret_0 = 0;
         m9_h = m1__ret_0;
      }
      skip;
      goto loc_162;
   }
loc_162:
   atomic { 
      skip;
      d_step {
         skip;
      }
      skip;
      goto loc_163;
   }
loc_163:
   if
   :: atomic { 
         (m9_h == 0)-> 
         goto loc_141;
      }
   :: atomic { 
         (! (m9_h == 0))-> 
         goto loc_164;
      }
   fi;
loc_164:
   atomic { 
      skip;
      d_step {
         m9_h = (GoodNight_minutes * 60);
         m9_amount = m9_h;
         if 
         :: ! (3600 == 0) -> 
            m9_JJJCTEMP_0 = (m9_amount / 3600);
         :: else -> 
            assert(0);
         fi; 
         m9_h = (m9_JJJCTEMP_0 + 1);
         m1_startTime_0 = STCurrentSystemTime;
         m1_startTime_0 = (m1_startTime_0 + m9_h);
         STCurrentSystemTime = m1_startTime_0;
      }
      skip;
      goto loc_175;
   }
loc_175:
   if
   :: atomic { 
         (location.mode == GoodNight_newMode)-> 
         goto loc_176;
      }
   :: atomic { 
         (! (location.mode == GoodNight_newMode))-> 
         goto loc_291;
      }
   fi;
loc_176:
   atomic { 
      skip;
      d_step {
         m10_1_m0__ret = 0;
         m9_h = m10_1_m0__ret;
      }
      skip;
      goto loc_179;
   }
loc_179:
   atomic { 
      skip;
      d_step {
         skip;
      }
      skip;
      goto loc_180;
   }
loc_180:
   if
   :: atomic { 
         (m9_h == 0)-> 
         goto loc_181;
      }
   :: atomic { 
         (! (m9_h == 0))-> 
         goto loc_183;
      }
   fi;
loc_181:
   atomic { 
      skip;
      d_step {
         skip;
      }
      skip;
      goto loc_141;
   }
loc_183:
   atomic { 
      skip;
      d_step {
         m10_1_m1_m2__ret = (STCurrentSystemTime * 3600000);
         m10_1_m1_t0 = m10_1_m1_m2__ret;
         m10_1_m1_m2__ret = (STCurrentSystemTime * 3600000);
         m10_1_m1_modeStartTime = m10_1_m1_m2__ret;
         m10_1_m1_m3_startTime = m10_1_m1_modeStartTime;
         m10_1_m1_m3_timeVal = GoodNight_timeOfDay;
         m10_1_m1_m3_timeZone = location.timeZone;
         m10_1_m1_m3__ret = (m10_1_m1_m3_timeVal * 3600000);
         m10_1_m1_startTime = m10_1_m1_m3__ret;
      }
      skip;
      goto loc_199;
   }
loc_199:
   if
   :: atomic { 
         (m10_1_m1_t0 < m10_1_m1_startTime)-> 
         goto loc_200;
      }
   :: atomic { 
         (! (m10_1_m1_t0 < m10_1_m1_startTime))-> 
         goto loc_288;
      }
   fi;
loc_200:
   atomic { 
      skip;
      d_step {
         m10_1_m1__ret = 0;
         m9_h = m10_1_m1__ret;
      }
      skip;
      goto loc_203;
   }
loc_203:
   atomic { 
      skip;
      d_step {
         skip;
      }
      skip;
      goto loc_204;
   }
loc_204:
   if
   :: atomic { 
         (m9_h == 0)-> 
         goto loc_181;
      }
   :: atomic { 
         (! (m9_h == 0))-> 
         goto loc_205;
      }
   fi;
loc_205:
   atomic { 
      skip;
      d_step {
         m9_h = (1000 * 60);
         m9_h = (m9_h * GoodNight_minutes);
         m10_1_m4_threshold = (m9_h - 1000);
         m10_1_m4_index5 = 0;
      }
      skip;
      goto loc_211;
   }
loc_211:
   atomic { 
      skip;
      d_step {
         m9_h = GoodNight_motionSensors.length;
      }
      skip;
      goto loc_212;
   }
loc_212:
   if
   :: atomic { 
         (m10_1_m4_index5 < m9_h)-> 
         goto loc_213;
      }
   :: atomic { 
         (! (m10_1_m4_index5 < m9_h))-> 
         goto loc_222;
      }
   fi;
loc_213:
   atomic { 
      skip;
      d_step {
         assign_STMotionSensor_rec(m10_1_m4_it, GoodNight_motionSensors.element[m10_1_m4_index5]);
         assign_STMotionSensor_rec(m10_1_m4_m5_1_JJJCTEMP_0, m10_1_m4_it);
         m10_1_m4_m5_1_attributeName = 11;
         assign_STState_rec(m10_1_m4_m5_1__ret, m10_1_m4_m5_1_JJJCTEMP_0.motionState);
         assign_STState_rec(m10_1_m4_m5_1__ret, m10_1_m4_m5_1__ret);
         m10_1_m4_collectResult1.length++;
         assign_STState_rec(m10_1_m4_collectResult1.element[m10_1_m4_index5], m10_1_m4_m5_1__ret);
         m10_1_m4_index5 = (m10_1_m4_index5 + 1);
      }
      skip;
      goto loc_211;
   }
loc_222:
   atomic { 
      skip;
      d_step {
         assign_STState_arr(m10_1_m4_states, m10_1_m4_collectResult1);
      }
      skip;
      goto loc_223;
   }
loc_223:
   if
   :: atomic { 
         (m10_1_m4_states.length == 0)-> 
         goto loc_224;
      }
   :: atomic { 
         (! (m10_1_m4_states.length == 0))-> 
         goto loc_261;
      }
   fi;
loc_224:
   atomic { 
      skip;
      d_step {
         m10_1_m4__ret = 1;
         m9_h = m10_1_m4__ret;
      }
      skip;
      goto loc_227;
   }
loc_227:
   atomic { 
      skip;
      d_step {
         skip;
      }
      skip;
      goto loc_228;
   }
loc_228:
   if
   :: atomic { 
         (m9_h == 0)-> 
         goto loc_181;
      }
   :: atomic { 
         (! (m9_h == 0))-> 
         goto loc_229;
      }
   fi;
loc_229:
   atomic { 
      skip;
      d_step {
         m10_1_m6_result = 1;
         m10_1_m6_index4 = 0;
      }
      skip;
      goto loc_234;
   }
loc_234:
   atomic { 
      skip;
      d_step {
         m10_1_m1__ret = GoodNight_switches.length;
      }
      skip;
      goto loc_235;
   }
loc_235:
   if
   :: atomic { 
         (m10_1_m6_index4 < m10_1_m1__ret)-> 
         goto loc_236;
      }
   :: atomic { 
         (! (m10_1_m6_index4 < m10_1_m1__ret))-> 
         goto loc_242;
      }
   fi;
loc_236:
   atomic { 
      skip;
      d_step {
         assign_STSwitch_rec(m10_1_m6_it, GoodNight_switches.element[m10_1_m6_index4]);
         m10_1_m1__ret = m10_1_m6_it.currentSwitch;
      }
      skip;
      goto loc_238;
   }
loc_238:
   if
   :: atomic { 
         (m10_1_m1__ret != 15)-> 
         goto loc_239;
      }
   :: atomic { 
         (! (m10_1_m1__ret != 15))-> 
         goto loc_240;
      }
   fi;
loc_239:
   atomic { 
      skip;
      d_step {
         m10_1_m6_index4 = (m10_1_m6_index4 + 1);
      }
      skip;
      goto loc_234;
   }
loc_240:
   atomic { 
      skip;
      d_step {
         m10_1_m6_result = 0;
      }
      skip;
      goto loc_242;
   }
loc_242:
   atomic { 
      skip;
      d_step {
         m10_1_m6__ret = m10_1_m6_result;
         m9_h = m10_1_m6__ret;
      }
      skip;
      goto loc_246;
   }
loc_246:
   if
   :: atomic { 
         (m9_h == 0)-> 
         goto loc_181;
      }
   :: atomic { 
         (! (m9_h == 0))-> 
         goto loc_247;
      }
   fi;
loc_247:
   atomic { 
      skip;
      d_step {
         m10_1_m7_m8_mode = GoodNight_newMode;
      }
      skip;
      goto loc_249;
   }
loc_249:
   if
   :: atomic { 
         (m10_1_m7_m8_mode != 1400)-> 
         goto loc_250;
      }
   :: atomic { 
         (! (m10_1_m7_m8_mode != 1400))-> 
         goto loc_259;
      }
   fi;
loc_250:
   if
   :: atomic { 
         (m10_1_m7_m8_mode != 1401)-> 
         goto loc_251;
      }
   :: atomic { 
         (! (m10_1_m7_m8_mode != 1401))-> 
         goto loc_257;
      }
   fi;
loc_251:
   if
   :: atomic { 
         (m10_1_m7_m8_mode != 1402)-> 
         goto loc_252;
      }
   :: atomic { 
         (! (m10_1_m7_m8_mode != 1402))-> 
         goto loc_256;
      }
   fi;
loc_252:
   atomic { 
      skip;
      d_step {
         skip;
      }
      skip;
      goto loc_181;
   }
loc_256:
   atomic { 
      skip;
      d_step {
         _ST_Command.EvtType = Night;
         HandleLocationEvt(_ST_Command);
      }
      skip;
      goto loc_252;
   }
loc_257:
   atomic { 
      skip;
      d_step {
         _ST_Command.EvtType = Away;
         HandleLocationEvt(_ST_Command);
      }
      skip;
      goto loc_252;
   }
loc_259:
   atomic { 
      skip;
      d_step {
         _ST_Command.EvtType = Home;
         HandleLocationEvt(_ST_Command);
      }
      skip;
      goto loc_252;
   }
loc_261:
   atomic { 
      skip;
      d_step {
         m10_1_m4_index6 = 0;
      }
      skip;
      goto loc_263;
   }
loc_263:
   atomic { 
      skip;
      d_step {
         m9_h = m10_1_m4_states.length;
      }
      skip;
      goto loc_264;
   }
loc_264:
   if
   :: atomic { 
         (m10_1_m4_index6 < m9_h)-> 
         goto loc_265;
      }
   :: atomic { 
         (! (m10_1_m4_index6 < m9_h))-> 
         goto loc_270;
      }
   fi;
loc_265:
   atomic { 
      skip;
      d_step {
         assign_STState_rec(m10_1_m4_it_0, m10_1_m4_states.element[m10_1_m4_index6]);
         m9_h = m10_1_m4_it_0.value;
      }
      skip;
      goto loc_267;
   }
loc_267:
   if
   :: atomic { 
         (m9_h != 12)-> 
         goto loc_268;
      }
   :: atomic { 
         (! (m9_h != 12))-> 
         goto loc_269;
      }
   fi;
loc_268:
   atomic { 
      skip;
      d_step {
         m10_1_m4_index6 = (m10_1_m4_index6 + 1);
      }
      skip;
      goto loc_263;
   }
loc_269:
   atomic { 
      skip;
      d_step {
         assign_STState_rec(m10_1_m4_findResult1, m10_1_m4_it_0);
      }
      skip;
      goto loc_268;
   }
loc_270:
   if
   :: atomic { 
         (m10_1_m4_findResult1.isAlive == 0)-> 
         goto loc_271;
      }
   :: atomic { 
         (! (m10_1_m4_findResult1.isAlive == 0))-> 
         goto loc_285;
      }
   fi;
loc_271:
   atomic { 
      skip;
      d_step {
         assign_STState_rec(m10_1_m4_sensor, m10_1_m4_states.element[0]);
         m10_1_m4_m2__ret = (STCurrentSystemTime * 3600000);
         m10_1_m1__ret = m10_1_m4_m2__ret;
         m9_h = m10_1_m4_sensor.date;
         m10_1_m4_elapsed = (m10_1_m1__ret - m9_h);
      }
      skip;
      goto loc_278;
   }
loc_278:
   if
   :: atomic { 
         (m10_1_m4_elapsed < m10_1_m4_threshold)-> 
         goto loc_279;
      }
   :: atomic { 
         (! (m10_1_m4_elapsed < m10_1_m4_threshold))-> 
         goto loc_282;
      }
   fi;
loc_279:
   atomic { 
      skip;
      d_step {
         m10_1_m4__ret = 0;
         m9_h = m10_1_m4__ret;
      }
      skip;
      goto loc_227;
   }
loc_282:
   atomic { 
      skip;
      d_step {
         m10_1_m4__ret = 1;
         m9_h = m10_1_m4__ret;
      }
      skip;
      goto loc_227;
   }
loc_285:
   atomic { 
      skip;
      d_step {
         m10_1_m4__ret = 0;
         m9_h = m10_1_m4__ret;
      }
      skip;
      goto loc_227;
   }
loc_288:
   atomic { 
      skip;
      d_step {
         m10_1_m1__ret = 1;
         m9_h = m10_1_m1__ret;
      }
      skip;
      goto loc_203;
   }
loc_291:
   atomic { 
      skip;
      d_step {
         m10_1_m0__ret = 1;
         m9_h = m10_1_m0__ret;
      }
      skip;
      goto loc_179;
   }
loc_294:
   atomic { 
      skip;
      d_step {
         m1__ret_0 = 1;
         m9_h = m1__ret_0;
      }
      skip;
      goto loc_162;
   }
loc_297:
   atomic { 
      skip;
      d_step {
         m0__ret_0 = 1;
         m9_h = m0__ret_0;
      }
      skip;
      goto loc_139;
   }
loc_300:
   atomic { 
      skip;
      d_step {
         GoodNight_modeStartTime = 0;
      }
      skip;
      goto loc_134;
   }
done: skip;
}

inline GoodNight_modeChangeEvtHandler(evt) {
   type_95 m2__ret;   
   type_95 JJJCTEMP_1;   
   STEvent_rec _ST_Command;

   /* Default initialization */
   d_step {
      _ST_Command.id = evt.id;
      _ST_Command.physical = 0;
   }
loc_302:
   atomic { 
      skip;
      d_step {
         m2__ret = (STCurrentSystemTime * 3600000);
         JJJCTEMP_1 = m2__ret;
         GoodNight_modeStartTime = JJJCTEMP_1;
      }
      skip;
      goto loc_307;
   }
loc_307:
   goto done;
done: skip;
}

hidden STState_rec m10_4_m5_4__ret;   
hidden STSwitch_rec m11_3_JJJCTEMP_0;   
hidden STSwitch_rec it;   
hidden STSwitch_rec m10_4_m12_5_JJJCTEMP_0;   
hidden STSwitch_rec m10_4_it;   
hidden STMotionSensor_rec m10_4_m5_4_JJJCTEMP_0;   
hidden STState_rec m10_4_motionState;   
inline LightFollowsMe_motionEvtHandler(evt) {
   type_95 m9_amount_0;   
   type_95 m10_4_index1;   
   type_95 m10_4_elapsed;   
   type_95 index0;   
   type_95 m10_4_threshold;   
   type_95 m10_4_m2__ret;   
   type_95 m10_4_m5_4_attributeName;   
   type_95 m9_JJJCTEMP_0_0;   
   type_95 m9_h_0;   
   type_95 JJJCTEMP_6;   
   STEvent_rec _ST_Command;

   /* Default initialization */
   d_step {
      m10_4_m5_4__ret.isAlive = 0;
      m11_3_JJJCTEMP_0.isAlive = 0;
      it.isAlive = 0;
      m10_4_m12_5_JJJCTEMP_0.isAlive = 0;
      m10_4_it.isAlive = 0;
      m10_4_m5_4_JJJCTEMP_0.isAlive = 0;
      m10_4_motionState.isAlive = 0;
      _ST_Command.id = evt.id;
      _ST_Command.physical = 0;
   }
loc_309:
   if
   :: atomic { 
         (evt.value != 12)-> 
         goto loc_310;
      }
   :: atomic { 
         (! (evt.value != 12))-> 
         goto loc_352;
      }
   fi;
loc_310:
   if
   :: atomic { 
         (evt.value != 13)-> 
         goto loc_311;
      }
   :: atomic { 
         (! (evt.value != 13))-> 
         goto loc_312;
      }
   fi;
loc_311:
   goto done;
loc_312:
   atomic { 
      skip;
      d_step {
         m9_amount_0 = (LightFollowsMe_minutes1 * 60);
         m9_amount_0 = m9_amount_0;
         if 
         :: ! (3600 == 0) -> 
            m9_JJJCTEMP_0_0 = (m9_amount_0 / 3600);
         :: else -> 
            assert(0);
         fi; 
         m9_h_0 = (m9_JJJCTEMP_0_0 + 1);
         m10_4_threshold = STCurrentSystemTime;
         m10_4_threshold = (m10_4_threshold + m9_h_0);
         STCurrentSystemTime = m10_4_threshold;
         assign_STMotionSensor_rec(m10_4_m5_4_JJJCTEMP_0, LightFollowsMe_motion1);
         m10_4_m5_4_attributeName = 11;
         assign_STState_rec(m10_4_m5_4__ret, m10_4_m5_4_JJJCTEMP_0.motionState);
         assign_STState_rec(m10_4_motionState, m10_4_m5_4__ret);
         m10_4_threshold = m10_4_motionState.value;
      }
      skip;
      goto loc_329;
   }
loc_329:
   if
   :: atomic { 
         (m10_4_threshold != 13)-> 
         goto loc_330;
      }
   :: atomic { 
         (! (m10_4_threshold != 13))-> 
         goto loc_332;
      }
   fi;
loc_330:
   atomic { 
      skip;
      d_step {
         skip;
      }
      skip;
      goto loc_311;
   }
loc_332:
   atomic { 
      skip;
      d_step {
         m10_4_m2__ret = (STCurrentSystemTime * 3600000);
         m9_amount_0 = m10_4_m2__ret;
         m10_4_threshold = m10_4_motionState.date;
         m10_4_elapsed = (m9_amount_0 - m10_4_threshold);
         m10_4_threshold = (1000 * 60);
         JJJCTEMP_6 = (m10_4_threshold * LightFollowsMe_minutes1);
         m10_4_threshold = (JJJCTEMP_6 - 1000);
      }
      skip;
      goto loc_341;
   }
loc_341:
   if
   :: atomic { 
         (m10_4_elapsed < m10_4_threshold)-> 
         goto loc_330;
      }
   :: atomic { 
         (! (m10_4_elapsed < m10_4_threshold))-> 
         goto loc_342;
      }
   fi;
loc_342:
   atomic { 
      skip;
      d_step {
         m10_4_index1 = 0;
      }
      skip;
      goto loc_344;
   }
loc_344:
   atomic { 
      skip;
      d_step {
         JJJCTEMP_6 = LightFollowsMe_switches.length;
      }
      skip;
      goto loc_345;
   }
loc_345:
   if
   :: atomic { 
         (m10_4_index1 < JJJCTEMP_6)-> 
         goto loc_346;
      }
   :: atomic { 
         (! (m10_4_index1 < JJJCTEMP_6))-> 
         goto loc_330;
      }
   fi;
loc_346:
   atomic { 
      skip;
      d_step {
         assign_STSwitch_rec(m10_4_it, LightFollowsMe_switches.element[m10_4_index1]);
         assign_STSwitch_rec(m10_4_m12_5_JJJCTEMP_0, m10_4_it);
         _ST_Command.EvtType = off;
         HandleSTSwitchEvt(m10_4_m12_5_JJJCTEMP_0.gArrIndex, _ST_Command);
         m10_4_index1 = (m10_4_index1 + 1);
      }
      skip;
      goto loc_344;
   }
loc_352:
   atomic { 
      skip;
      d_step {
         index0 = 0;
      }
      skip;
      goto loc_354;
   }
loc_354:
   atomic { 
      skip;
      d_step {
         JJJCTEMP_6 = LightFollowsMe_switches.length;
      }
      skip;
      goto loc_355;
   }
loc_355:
   if
   :: atomic { 
         (index0 < JJJCTEMP_6)-> 
         goto loc_356;
      }
   :: atomic { 
         (! (index0 < JJJCTEMP_6))-> 
         goto loc_362;
      }
   fi;
loc_356:
   atomic { 
      skip;
      d_step {
         assign_STSwitch_rec(it, LightFollowsMe_switches.element[index0]);
         assign_STSwitch_rec(m11_3_JJJCTEMP_0, it);
         _ST_Command.EvtType = on;
         HandleSTSwitchEvt(m11_3_JJJCTEMP_0.gArrIndex, _ST_Command);
         index0 = (index0 + 1);
      }
      skip;
      goto loc_354;
   }
loc_362:
   atomic { 
      skip;
      d_step {
         skip;
      }
      skip;
      goto loc_311;
   }
done: skip;
}

hidden STLock_rec m13_7_JJJCTEMP_0;   
hidden STLock_rec it_0;   
inline UnlockDoor_changedLocationModeEvtHandler(evt) {
   type_95 index2;   
   type_95 JJJCTEMP_4;   
   STEvent_rec _ST_Command;

   /* Default initialization */
   d_step {
      m13_7_JJJCTEMP_0.isAlive = 0;
      it_0.isAlive = 0;
      _ST_Command.id = evt.id;
      _ST_Command.physical = 0;
   }
loc_364:
   atomic { 
      skip;
      d_step {
         index2 = 0;
      }
      skip;
      goto loc_366;
   }
loc_366:
   atomic { 
      skip;
      d_step {
         JJJCTEMP_4 = UnlockDoor_locks.length;
      }
      skip;
      goto loc_367;
   }
loc_367:
   if
   :: atomic { 
         (index2 < JJJCTEMP_4)-> 
         goto loc_368;
      }
   :: atomic { 
         (! (index2 < JJJCTEMP_4))-> 
         goto loc_374;
      }
   fi;
loc_368:
   atomic { 
      skip;
      d_step {
         assign_STLock_rec(it_0, UnlockDoor_locks.element[index2]);
         assign_STLock_rec(m13_7_JJJCTEMP_0, it_0);
         _ST_Command.EvtType = unlock;
         HandleSTLockEvt(m13_7_JJJCTEMP_0.gArrIndex, _ST_Command);
         index2 = (index2 + 1);
      }
      skip;
      goto loc_366;
   }
loc_374:
   goto done;
done: skip;
}

hidden STSwitch_rec m12_9_JJJCTEMP_0;   
inline LightOffWhenClosed_contactClosedEvtHandler(evt) {
   STEvent_rec _ST_Command;

   /* Default initialization */
   d_step {
      m12_9_JJJCTEMP_0.isAlive = 0;
      _ST_Command.id = evt.id;
      _ST_Command.physical = 0;
   }
loc_376:
   atomic { 
      skip;
      d_step {
         assign_STSwitch_rec(m12_9_JJJCTEMP_0, LightOffWhenClosed_switch1);
         _ST_Command.EvtType = off;
         HandleSTSwitchEvt(m12_9_JJJCTEMP_0.gArrIndex, _ST_Command);
      }
      skip;
      goto loc_380;
   }
loc_380:
   goto done;
done: skip;
}
/*************** End of event handler inline methods *********/

/********* Start of utility definitions ****************/
/* mtype m; int result */
inline getIntValueFromMtype(m, result)
{
	if
	:: m == inactive -> result = INACTIVE;
	:: m == _active -> result = ACTIVE;
	:: m == on -> result = ON;
	:: m == off -> result = OFF;
	:: m == notpresent -> result = NOT_PRESENT;
	:: m == present -> result = PRESENT;
	:: m == fanAuto -> result = AUTO;
	:: m == fanCirculate -> result = CIRCULATE;
	:: m == fanOn -> result = ON;
	:: m == auto -> result = AUTO;
	:: m == cool -> result = COOL;
	:: m == emergencyHeat -> result = EMERGENCY_HEAT;
	:: m == heat -> result = HEAT;
	:: m == lock -> result = LOCKED;
	:: m == unlock -> result = UNLOCKED;
	:: m == clear -> result = CLEAR;
	:: m == detected -> result = DETECTED;
	:: m == tested -> result = TESTED;
	:: m == close -> result = CLOSED;
	:: m == open -> result = OPEN;
	:: m == Home -> result = HOME;
	:: m == Away -> result = AWAY;
	:: m == Night -> result = NIGHT;
	:: m == temperature -> result = TEMPERATURE;
	:: m == alarm -> result = ALARM;
	:: m == both -> result = BOTH;
	:: m == siren -> result = SIREN;
	:: m == strobe -> result = STROBE;
	:: m == pushed -> result = PUSHED;
	:: m == held -> result = HELD;
	:: m == setLevel -> result = LEVEL;
	:: else -> result = 0;
	fi
}
/* byte currIndex; byte prevIndex */
inline getPrevStoredEvtIndex(currIndex, prevIndex)
{
	if
	:: currIndex == 0 -> prevIndex = (MAX_STORED_EVENTS-1);
	:: !(currIndex == 0) -> prevIndex = (currIndex-1);
	fi
}
inline ResetGlobalVariables()
{
	/* Reset system variables */
	location.NumReceivedCommands = 0;

	/* Reset device variables */
	_g_STLockArr.element[doorLock_STLock].NumReceivedCommands = 0;
	_g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor].NumReceivedCommands = 0;
	_g_STSwitchArr.element[livingRoomBulb_STSwitch].NumReceivedCommands = 0;
	_g_STSwitchArr.element[bedRoomBulb_STSwitch].NumReceivedCommands = 0;
	_g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor].NumReceivedCommands = 0;
	_g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor].NumReceivedCommands = 0;
	_g_STContactSensorArr.element[bedRoomDoor_STContactSensor].NumReceivedCommands = 0;
}
inline ResetDeviceDefaultState()
{
	/* Reset default state of devices */
		_g_STLockArr.element[doorLock_STLock].currentLock = LOCKED;
		_g_STLockArr.element[doorLock_STLock].lockState.value = LOCKED;
		_g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor].currentMotion = INACTIVE;
		_g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor].motionState.value = INACTIVE;
		_g_STSwitchArr.element[livingRoomBulb_STSwitch].currentSwitch = OFF;
		_g_STSwitchArr.element[livingRoomBulb_STSwitch].switchState.value = OFF;
		_g_STSwitchArr.element[bedRoomBulb_STSwitch].currentSwitch = OFF;
		_g_STSwitchArr.element[bedRoomBulb_STSwitch].switchState.value = OFF;
		_g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor].currentMotion = INACTIVE;
		_g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor].motionState.value = INACTIVE;
		_g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor].currentMotion = INACTIVE;
		_g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor].motionState.value = INACTIVE;
		_g_STContactSensorArr.element[bedRoomDoor_STContactSensor].currentContact = CLOSED;
		_g_STContactSensorArr.element[bedRoomDoor_STContactSensor].contactState.value = CLOSED;
}
/********* End of utility definitions ******************/

/*************** Start of location manager *******************/
hidden byte _index0;
inline HandleLocationEvt(Evt)
{
	short HandleLocationEvt_mode;

	d_step {
		if
		:: (Evt.EvtType == Home) || (Evt.EvtType == Night) || (Evt.EvtType == Away) -> {
			/* Check conflict commands */
			if
			:: (location.latestEvt.id == Evt.id) && (location.latestEvt.date == STCurrentSystemTime*3600000) -> assert(Evt.EvtType == location.latestEvt.EvtType);
			:: else -> skip;
			fi

			/* Increase number of received commands per event */
			if
			:: (Evt.id == location.latestEvt.id) || (location.latestEvt.id == 0) -> location.NumReceivedCommands++;
			:: else -> skip;
			fi
			/* Check DOS attack or infinite loop of commands */
			if
			:: (location.NumReceivedCommands >= MAX_COMMAND_REPITIONS) -> assert(0);
			:: else -> skip;
			fi

			/* Update current mode */
			getIntValueFromMtype(Evt.EvtType, HandleLocationEvt_mode);
			location.mode = HandleLocationEvt_mode;
			Evt.name = MODE;
			Evt.value = HandleLocationEvt_mode;
			Evt.date = STCurrentSystemTime*3600000;
			Evt.isAlive = 1;
		}
		:: else -> skip;
		fi
		/* Store the current event */
		assign_STEvent_rec(location.latestEvt, Evt);

		/* Broadcast the mode change event to subscribers */
			for(_index0 : 0 .. location.NumSubscribers-1) {
				location.BroadcastChans[_index0] = true;
			}
	}
}
inline ChangeLocationMode(Evt)
{
	d_step {
		if
		:: Evt.EvtType == present -> location.mode = HOME;
		:: else -> skip;
		fi
	}
}
inline InitializeLocation()
{
	location.NumSubscribers = 0;
	location.mode = HOME;
	location.modes.length = 3;
	location.modes.element[0].name = HOME;
	location.modes.element[0].isAlive = 1;
	location.modes.element[1].name = AWAY;
	location.modes.element[1].isAlive = 1;
	location.modes.element[2].name = NIGHT;
	location.modes.element[2].isAlive = 1;
	location.sunriseSunset.sunrise = ST_SUNRISE_TIME;
	location.sunriseSunset.sunset = ST_SUNSET_TIME;
	location.sunriseSunset.isAlive = 1;
}
/*************** End of location manager *********************/

/*************** Start of network manager ********************/
inline HandleNetworkEvt(_ST_Command)
{
	d_step {
		/* Verify the recipient for sendSms */
		if
		:: (_ST_Command.EvtType == sendSms) -> {
			if
			:: (_STNetworkManager.configuredPhoneNumber == 0) -> assert(0);
			:: (_STNetworkManager.configuredPhoneNumber != _STNetworkManager.receivedPhoneNumber) -> assert(0);
			:: else -> skip;
			fi
		}
		:: (_ST_Command.EvtType == httpPost) -> {
			if
			:: (httpPostAllowed == false) -> assert(0);
			:: !((httpPostAllowed == false)) -> skip;
			fi
		}
		:: (_ST_Command.EvtType == unsubscribe) -> assert(0);
		:: else -> skip;
		fi
	}
}
/*************** End of network manager **********************/

/*************** Start of actuator device event handler ******/
hidden byte _index1;
inline HandleSTLockEvt(deviceIndex, Evt)
{
	byte latestEvtIndex1;
	short HandleSTLockEvt_state;

	d_step {
		_g_STLockArr.element[deviceIndex].isOnline = 1;
		/* Smart app cannot change lock code */
		if
		:: Evt.EvtType == usercodechange -> assert(0);
		:: else -> skip;
		fi

		/* Validate the counter */
		if
		:: _g_STLockArr.element[deviceIndex].currEvtIndex >= MAX_STORED_EVENTS -> _g_STLockArr.element[deviceIndex].currEvtIndex = 0;
		:: else -> skip;
		fi

		/* Check conflict commands */
		getPrevStoredEvtIndex(_g_STLockArr.element[deviceIndex].currEvtIndex, latestEvtIndex1);
		if
		:: (Evt.physical == 0) && (_g_STLockArr.element[deviceIndex].events.element[latestEvtIndex1].id == Evt.id) && (_g_STLockArr.element[deviceIndex].events.element[latestEvtIndex1].date == STCurrentSystemTime*3600000) -> 
			assert(Evt.EvtType == _g_STLockArr.element[deviceIndex].events.element[latestEvtIndex1].EvtType);
		:: else -> skip;
		fi

		/* Increase number of received commands per event */
		if
		:: (Evt.physical == 0) && (_g_STLockArr.element[deviceIndex].events.element[latestEvtIndex1].id == 0) || ((_g_STLockArr.element[deviceIndex].events.element[latestEvtIndex1].id == Evt.id) && (_g_STLockArr.element[deviceIndex].events.element[latestEvtIndex1].date == STCurrentSystemTime*3600000)) -> _g_STLockArr.element[deviceIndex].NumReceivedCommands++;
		:: else -> skip;
		fi
		/* Check DOS attack or infinite loop of commands */
		if
		:: (_g_STLockArr.element[deviceIndex].NumReceivedCommands >= MAX_COMMAND_REPITIONS) -> assert(0);
		:: else -> skip;
		fi

		/* Update current state if it is different from latest state */
		if
		:: (Evt.EvtType != _g_STLockArr.element[deviceIndex].events.element[latestEvtIndex1].EvtType) || (_g_STLockArr.element[deviceIndex].events.element[latestEvtIndex1].id == 0) -> {
			getIntValueFromMtype(Evt.EvtType, HandleSTLockEvt_state);
			_g_STLockArr.element[deviceIndex].currentLock = HandleSTLockEvt_state;
			_g_STLockArr.element[deviceIndex].lockState.value = HandleSTLockEvt_state;
			_g_STLockArr.element[deviceIndex].lockState.name = LOCK;
			_g_STLockArr.element[deviceIndex].lockState.date = STCurrentSystemTime*3600000;
			_g_STLockArr.element[deviceIndex].lockState.isAlive = 1;

			/* Store new state */
			assign_STState_rec(_g_STLockArr.element[deviceIndex].states.element[_g_STLockArr.element[deviceIndex].currEvtIndex], _g_STLockArr.element[deviceIndex].lockState);

			/* Store the current event */
			Evt.name = LOCK;
			Evt.value = HandleSTLockEvt_state;
			Evt.date = STCurrentSystemTime*3600000;
			Evt.isAlive = 1;
			assign_STEvent_rec(_g_STLockArr.element[deviceIndex].events.element[_g_STLockArr.element[deviceIndex].currEvtIndex], Evt);

			/* Increment the counter */
			_g_STLockArr.element[deviceIndex].currEvtIndex++;

			/* Broadcast the state change event to subscribers */
			for(_index1 : 0 .. _g_STLockArr.element[deviceIndex].NumSubscribers-1) {
				_g_STLockArr.element[deviceIndex].BroadcastChans[_index1] = true;
			}
		}
		:: else -> skip;
		fi
	}
}
hidden byte _index2;
inline HandleSTSwitchEvt(deviceIndex, Evt)
{
	byte latestEvtIndex2;
	short HandleSTSwitchEvt_state;

	d_step {
		_g_STSwitchArr.element[deviceIndex].isOnline = 1;
		/* Validate the counter */
		if
		:: _g_STSwitchArr.element[deviceIndex].currEvtIndex >= MAX_STORED_EVENTS -> _g_STSwitchArr.element[deviceIndex].currEvtIndex = 0;
		:: else -> skip;
		fi

		/* Check conflict commands */
		getPrevStoredEvtIndex(_g_STSwitchArr.element[deviceIndex].currEvtIndex, latestEvtIndex2);
		if
		:: (Evt.physical == 0) && (_g_STSwitchArr.element[deviceIndex].events.element[latestEvtIndex2].id == Evt.id) && (_g_STSwitchArr.element[deviceIndex].events.element[latestEvtIndex2].date == STCurrentSystemTime*3600000) -> 
			assert(Evt.EvtType == _g_STSwitchArr.element[deviceIndex].events.element[latestEvtIndex2].EvtType);
		:: else -> skip;
		fi

		/* Increase number of received commands per event */
		if
		:: (Evt.physical == 0) && (_g_STSwitchArr.element[deviceIndex].events.element[latestEvtIndex2].id == 0) || ((_g_STSwitchArr.element[deviceIndex].events.element[latestEvtIndex2].id == Evt.id) && (_g_STSwitchArr.element[deviceIndex].events.element[latestEvtIndex2].date == STCurrentSystemTime*3600000)) -> _g_STSwitchArr.element[deviceIndex].NumReceivedCommands++;
		:: else -> skip;
		fi
		/* Check DOS attack or infinite loop of commands */
		if
		:: (_g_STSwitchArr.element[deviceIndex].NumReceivedCommands >= MAX_COMMAND_REPITIONS) -> assert(0);
		:: else -> skip;
		fi

		/* Update current state if it is different from latest state */
		if
		:: (Evt.EvtType != _g_STSwitchArr.element[deviceIndex].events.element[latestEvtIndex2].EvtType) || (_g_STSwitchArr.element[deviceIndex].events.element[latestEvtIndex2].id == 0) -> {
			getIntValueFromMtype(Evt.EvtType, HandleSTSwitchEvt_state);
			_g_STSwitchArr.element[deviceIndex].currentSwitch = HandleSTSwitchEvt_state;
			_g_STSwitchArr.element[deviceIndex].switchState.value = HandleSTSwitchEvt_state;
			_g_STSwitchArr.element[deviceIndex].switchState.name = SWITCH;
			_g_STSwitchArr.element[deviceIndex].switchState.date = STCurrentSystemTime*3600000;
			_g_STSwitchArr.element[deviceIndex].switchState.isAlive = 1;

			/* Store new state */
			assign_STState_rec(_g_STSwitchArr.element[deviceIndex].states.element[_g_STSwitchArr.element[deviceIndex].currEvtIndex], _g_STSwitchArr.element[deviceIndex].switchState);

			/* Store the current event */
			Evt.name = SWITCH;
			Evt.value = HandleSTSwitchEvt_state;
			Evt.date = STCurrentSystemTime*3600000;
			Evt.isAlive = 1;
			assign_STEvent_rec(_g_STSwitchArr.element[deviceIndex].events.element[_g_STSwitchArr.element[deviceIndex].currEvtIndex], Evt);

			/* Increment the counter */
			_g_STSwitchArr.element[deviceIndex].currEvtIndex++;

			/* Broadcast the state change event to subscribers */
			for(_index2 : 0 .. _g_STSwitchArr.element[deviceIndex].NumSubscribers-1) {
				_g_STSwitchArr.element[deviceIndex].BroadcastChans[_index2] = true;
			}
		}
		:: else -> skip;
		fi
	}
}
/*************** End of actuator device event handler ********/

/*************** Start of sensor device event handler ********/
hidden byte _index3;
inline HandleSTMotionSensorEvt(deviceIndex, Evt)
{
	d_step {
		/* Validate the currEvtIndex */
		if
		:: _g_STMotionSensorArr.element[deviceIndex].currEvtIndex >= MAX_STORED_EVENTS -> _g_STMotionSensorArr.element[deviceIndex].currEvtIndex = 0;
		:: else -> skip;
		fi

		/* Store the generated event */
		assign_STEvent_rec(_g_STMotionSensorArr.element[deviceIndex].events.element[_g_STMotionSensorArr.element[deviceIndex].currEvtIndex], Evt);

		/* Update current state */
		_g_STMotionSensorArr.element[deviceIndex].currentMotion = Evt.value;
		_g_STMotionSensorArr.element[deviceIndex].motionState.name = Evt.name;
		_g_STMotionSensorArr.element[deviceIndex].motionState.value = Evt.value;
		_g_STMotionSensorArr.element[deviceIndex].motionState.date = Evt.date;
		_g_STMotionSensorArr.element[deviceIndex].motionState.isAlive = 1;

		/* Store new state */
		assign_STState_rec(_g_STMotionSensorArr.element[deviceIndex].states.element[_g_STMotionSensorArr.element[deviceIndex].currEvtIndex], _g_STMotionSensorArr.element[deviceIndex].motionState);

		/* Increment the counter */
		_g_STMotionSensorArr.element[deviceIndex].currEvtIndex++;

		/* Broadcast the generated event to subscribers */
		for(_index3 : 0 .. _g_STMotionSensorArr.element[deviceIndex].NumSubscribers-1) {
			_g_STMotionSensorArr.element[deviceIndex].BroadcastChans[_index3] = true;
		}
	}
}
hidden byte _index4;
inline HandleSTContactSensorEvt(deviceIndex, Evt)
{
	d_step {
		/* Validate the currEvtIndex */
		if
		:: _g_STContactSensorArr.element[deviceIndex].currEvtIndex >= MAX_STORED_EVENTS -> _g_STContactSensorArr.element[deviceIndex].currEvtIndex = 0;
		:: else -> skip;
		fi

		/* Store the generated event */
		assign_STEvent_rec(_g_STContactSensorArr.element[deviceIndex].events.element[_g_STContactSensorArr.element[deviceIndex].currEvtIndex], Evt);

		/* Update current state */
		_g_STContactSensorArr.element[deviceIndex].currentContact = Evt.value;
		_g_STContactSensorArr.element[deviceIndex].contactState.name = Evt.name;
		_g_STContactSensorArr.element[deviceIndex].contactState.value = Evt.value;
		_g_STContactSensorArr.element[deviceIndex].contactState.date = Evt.date;
		_g_STContactSensorArr.element[deviceIndex].contactState.isAlive = 1;

		/* Store new state */
		assign_STState_rec(_g_STContactSensorArr.element[deviceIndex].states.element[_g_STContactSensorArr.element[deviceIndex].currEvtIndex], _g_STContactSensorArr.element[deviceIndex].contactState);

		/* Increment the counter */
		_g_STContactSensorArr.element[deviceIndex].currEvtIndex++;

		/* Broadcast the generated event to subscribers */
		for(_index4 : 0 .. _g_STContactSensorArr.element[deviceIndex].NumSubscribers-1) {
			_g_STContactSensorArr.element[deviceIndex].BroadcastChans[_index4] = true;
		}
	}
}
/*************** End of sensor device event handler **********/

/*************** Start of events generator *******************/
hidden byte STMotionSensorIndex;
hidden byte STContactSensorIndex;
bool eventProcessed, sunriseDone, sunsetDone;
proctype SmartThings()
{
	byte powerMeter;
	byte evtId;
	STEvent_rec generatedEvent;
	byte latestEvtIndex5;
	bool allEvtsHandled, systemTimeIncrementNeeded;

	d_step {
		STCurrentSystemTime = 1;
		generatedEvent.id = evtId;
		generatedEvent.date = STCurrentSystemTime*3600000;
		generatedEvent.isAlive = 1;
		generatedEvent.physical = 1;
		sunriseDone = false;
		sunsetDone = false;
	}
	GoodNight_installedEvtHandler(generatedEvent);
	ResetDeviceDefaultState();

	for(evtId : 2 .. MAX_NUM_EVENTS) {
		d_step {
			ResetGlobalVariables();
			eventProcessed = false;
			STCurrentSystemTime = evtId;
			generatedEvent.date = STCurrentSystemTime*3600000;
			generatedEvent.id = evtId;
			generatedEvent.isAlive = 1;
			generatedEvent.physical = 1;
		}

		/* Randomly select system temperature */
		if
		:: STCurrentTemperature = 1;
		:: STCurrentTemperature = 2;
		:: STCurrentTemperature = 3;
		fi

		/* Generate location events */
		if
		:: (STCurrentSystemTime >= location.sunriseSunset.sunrise) && (sunriseDone == false) -> {
			sunriseDone = true;
			generatedEvent.EvtType = sunriseTime;
			generatedEvent.value = STCurrentSystemTime;
			generatedEvent.name = SUNRISETIME;
			HandleLocationEvt(generatedEvent);
			skip;
			goto loc_StartOfEvtHandlers;
		}
		:: (STCurrentSystemTime >= location.sunriseSunset.sunset) && (sunsetDone == false) -> {
			sunsetDone = true;
			generatedEvent.EvtType = sunsetTime;
			generatedEvent.value = STCurrentSystemTime;
			generatedEvent.name = SUNSETTIME;
			HandleLocationEvt(generatedEvent);
			skip;
			goto loc_StartOfEvtHandlers;
		}
		:: else -> skip;
		fi

		/* Randomly generate an event */
		if
		/* Generate events for motion sensors */
		:: {
			d_step {
				STMotionSensorIndex++;
				/* Validate counter */
				if
				:: STMotionSensorIndex >= _g_STMotionSensorArr.length -> STMotionSensorIndex = 0;
				:: else -> skip;
				fi
			}

			if
			:: generatedEvent.EvtType = inactive; generatedEvent.value = INACTIVE;
			:: generatedEvent.EvtType = _active; generatedEvent.value = ACTIVE;
			fi
			generatedEvent.name = MOTION;
			HandleSTMotionSensorEvt(STMotionSensorIndex, generatedEvent);
		}
		/* Generate events for presence sensor */
		:: {
			d_step {
				STContactSensorIndex++;
				/* Validate counter */
				if
				:: STContactSensorIndex >= _g_STContactSensorArr.length -> STContactSensorIndex = 0;
				:: else -> skip;
				fi
			}

			if
			:: generatedEvent.EvtType = close; generatedEvent.value = CLOSED;
			:: generatedEvent.EvtType = open; generatedEvent.value = OPEN;
			fi
			generatedEvent.name = CONTACT;
			HandleSTContactSensorEvt(STContactSensorIndex, generatedEvent);
		}
		fi

loc_StartOfEvtHandlers:
		allEvtsHandled = true;
		systemTimeIncrementNeeded = false;

		/* Handlers of UnlockDoor */
		if
		:: location.BroadcastChans[UnlockDoor_location] == true -> atomic {
			allEvtsHandled = false;
			/* Reset broadcast event indicator */
			location.BroadcastChans[UnlockDoor_location] = false;

			/* Fetch current data of global variables */
			d_step {
				assign_STLock_rec(UnlockDoor_locks.element[0], _g_STLockArr.element[doorLock_STLock]);
			}

			if
			:: (location.latestEvt.EvtType == Home) || (location.latestEvt.EvtType == Away) || (location.latestEvt.EvtType == Night) -> UnlockDoor_changedLocationModeEvtHandler(location.latestEvt);
			:: else -> skip;
			fi
		}
		:: else -> skip;
		fi

		/* Handlers of GoodNight */
		if
		:: _g_STMotionSensorArr.element[GoodNight_motionSensors.element[0].gArrIndex].BroadcastChans[GoodNight_motionSensors.element[0].BroadcastChanIndex] == true -> atomic {
			allEvtsHandled = false;
			/* Reset broadcast event indicator */
			 _g_STMotionSensorArr.element[GoodNight_motionSensors.element[0].gArrIndex].BroadcastChans[GoodNight_motionSensors.element[0].BroadcastChanIndex] = false

			/* Get latest event */
			getPrevStoredEvtIndex(_g_STMotionSensorArr.element[GoodNight_motionSensors.element[0].gArrIndex].currEvtIndex, latestEvtIndex5);
			assign_STEvent_rec(generatedEvent, _g_STMotionSensorArr.element[GoodNight_motionSensors.element[0].gArrIndex].events.element[latestEvtIndex5]);

			/* Fetch current data of global variables */
			d_step {
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[0], _g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor]);
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[1], _g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor]);
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[2], _g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor]);
				assign_STSwitch_rec(GoodNight_switches.element[0], _g_STSwitchArr.element[livingRoomBulb_STSwitch]);
				assign_STSwitch_rec(GoodNight_switches.element[1], _g_STSwitchArr.element[bedRoomBulb_STSwitch]);
			}

			if
			:: generatedEvent.EvtType == _active -> skip;
			:: generatedEvent.EvtType == inactive -> GoodNight_motionInactiveEvtHandler(generatedEvent);
			:: else -> skip;
			fi
		}
		:: else -> skip;
		fi
		if
		:: _g_STMotionSensorArr.element[GoodNight_motionSensors.element[1].gArrIndex].BroadcastChans[GoodNight_motionSensors.element[1].BroadcastChanIndex] == true -> atomic {
			allEvtsHandled = false;
			/* Reset broadcast event indicator */
			 _g_STMotionSensorArr.element[GoodNight_motionSensors.element[1].gArrIndex].BroadcastChans[GoodNight_motionSensors.element[1].BroadcastChanIndex] = false

			/* Get latest event */
			getPrevStoredEvtIndex(_g_STMotionSensorArr.element[GoodNight_motionSensors.element[1].gArrIndex].currEvtIndex, latestEvtIndex5);
			assign_STEvent_rec(generatedEvent, _g_STMotionSensorArr.element[GoodNight_motionSensors.element[1].gArrIndex].events.element[latestEvtIndex5]);

			/* Fetch current data of global variables */
			d_step {
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[0], _g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor]);
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[1], _g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor]);
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[2], _g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor]);
				assign_STSwitch_rec(GoodNight_switches.element[0], _g_STSwitchArr.element[livingRoomBulb_STSwitch]);
				assign_STSwitch_rec(GoodNight_switches.element[1], _g_STSwitchArr.element[bedRoomBulb_STSwitch]);
			}

			if
			:: generatedEvent.EvtType == _active -> skip;
			:: generatedEvent.EvtType == inactive -> GoodNight_motionInactiveEvtHandler(generatedEvent);
			:: else -> skip;
			fi
		}
		:: else -> skip;
		fi
		if
		:: _g_STMotionSensorArr.element[GoodNight_motionSensors.element[2].gArrIndex].BroadcastChans[GoodNight_motionSensors.element[2].BroadcastChanIndex] == true -> atomic {
			allEvtsHandled = false;
			/* Reset broadcast event indicator */
			 _g_STMotionSensorArr.element[GoodNight_motionSensors.element[2].gArrIndex].BroadcastChans[GoodNight_motionSensors.element[2].BroadcastChanIndex] = false

			/* Get latest event */
			getPrevStoredEvtIndex(_g_STMotionSensorArr.element[GoodNight_motionSensors.element[2].gArrIndex].currEvtIndex, latestEvtIndex5);
			assign_STEvent_rec(generatedEvent, _g_STMotionSensorArr.element[GoodNight_motionSensors.element[2].gArrIndex].events.element[latestEvtIndex5]);

			/* Fetch current data of global variables */
			d_step {
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[0], _g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor]);
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[1], _g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor]);
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[2], _g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor]);
				assign_STSwitch_rec(GoodNight_switches.element[0], _g_STSwitchArr.element[livingRoomBulb_STSwitch]);
				assign_STSwitch_rec(GoodNight_switches.element[1], _g_STSwitchArr.element[bedRoomBulb_STSwitch]);
			}

			if
			:: generatedEvent.EvtType == _active -> skip;
			:: generatedEvent.EvtType == inactive -> GoodNight_motionInactiveEvtHandler(generatedEvent);
			:: else -> skip;
			fi
		}
		:: else -> skip;
		fi
		if
		:: _g_STSwitchArr.element[GoodNight_switches.element[0].gArrIndex].BroadcastChans[GoodNight_switches.element[0].BroadcastChanIndex] == true -> atomic {
			allEvtsHandled = false;
			/* Reset broadcast event indicator */
			 _g_STSwitchArr.element[GoodNight_switches.element[0].gArrIndex].BroadcastChans[GoodNight_switches.element[0].BroadcastChanIndex] = false

			/* Get latest event */
			getPrevStoredEvtIndex(_g_STSwitchArr.element[GoodNight_switches.element[0].gArrIndex].currEvtIndex, latestEvtIndex5);
			assign_STEvent_rec(generatedEvent, _g_STSwitchArr.element[GoodNight_switches.element[0].gArrIndex].events.element[latestEvtIndex5]);

			/* Fetch current data of global variables */
			d_step {
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[0], _g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor]);
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[1], _g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor]);
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[2], _g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor]);
				assign_STSwitch_rec(GoodNight_switches.element[0], _g_STSwitchArr.element[livingRoomBulb_STSwitch]);
				assign_STSwitch_rec(GoodNight_switches.element[1], _g_STSwitchArr.element[bedRoomBulb_STSwitch]);
			}

			if
			:: generatedEvent.EvtType == off -> GoodNight_switchOffEvtHandler(generatedEvent);
			:: else -> skip;
			fi
		}
		:: else -> skip;
		fi
		if
		:: _g_STSwitchArr.element[GoodNight_switches.element[1].gArrIndex].BroadcastChans[GoodNight_switches.element[1].BroadcastChanIndex] == true -> atomic {
			allEvtsHandled = false;
			/* Reset broadcast event indicator */
			 _g_STSwitchArr.element[GoodNight_switches.element[1].gArrIndex].BroadcastChans[GoodNight_switches.element[1].BroadcastChanIndex] = false

			/* Get latest event */
			getPrevStoredEvtIndex(_g_STSwitchArr.element[GoodNight_switches.element[1].gArrIndex].currEvtIndex, latestEvtIndex5);
			assign_STEvent_rec(generatedEvent, _g_STSwitchArr.element[GoodNight_switches.element[1].gArrIndex].events.element[latestEvtIndex5]);

			/* Fetch current data of global variables */
			d_step {
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[0], _g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor]);
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[1], _g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor]);
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[2], _g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor]);
				assign_STSwitch_rec(GoodNight_switches.element[0], _g_STSwitchArr.element[livingRoomBulb_STSwitch]);
				assign_STSwitch_rec(GoodNight_switches.element[1], _g_STSwitchArr.element[bedRoomBulb_STSwitch]);
			}

			if
			:: generatedEvent.EvtType == off -> GoodNight_switchOffEvtHandler(generatedEvent);
			:: else -> skip;
			fi
		}
		:: else -> skip;
		fi
		if
		:: location.BroadcastChans[GoodNight_location] == true -> atomic {
			allEvtsHandled = false;
			/* Reset broadcast event indicator */
			location.BroadcastChans[GoodNight_location] = false;

			/* Fetch current data of global variables */
			d_step {
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[0], _g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor]);
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[1], _g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor]);
				assign_STMotionSensor_rec(GoodNight_motionSensors.element[2], _g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor]);
				assign_STSwitch_rec(GoodNight_switches.element[0], _g_STSwitchArr.element[livingRoomBulb_STSwitch]);
				assign_STSwitch_rec(GoodNight_switches.element[1], _g_STSwitchArr.element[bedRoomBulb_STSwitch]);
			}

			if
			:: (location.latestEvt.EvtType == Home) || (location.latestEvt.EvtType == Away) || (location.latestEvt.EvtType == Night) -> GoodNight_modeChangeEvtHandler(location.latestEvt);
			:: else -> skip;
			fi
		}
		:: else -> skip;
		fi

		/* Handlers of LightOffWhenClosed */
		if
		:: _g_STContactSensorArr.element[LightOffWhenClosed_contact1.gArrIndex].BroadcastChans[LightOffWhenClosed_contact1.BroadcastChanIndex] == true -> atomic {
			allEvtsHandled = false;
			/* Reset broadcast event indicator */
			 _g_STContactSensorArr.element[LightOffWhenClosed_contact1.gArrIndex].BroadcastChans[LightOffWhenClosed_contact1.BroadcastChanIndex] = false

			/* Get latest event */
			getPrevStoredEvtIndex(_g_STContactSensorArr.element[LightOffWhenClosed_contact1.gArrIndex].currEvtIndex, latestEvtIndex5);
			assign_STEvent_rec(generatedEvent, _g_STContactSensorArr.element[LightOffWhenClosed_contact1.gArrIndex].events.element[latestEvtIndex5]);

			/* Fetch current data of global variables */
			d_step {
				assign_STContactSensor_rec(LightOffWhenClosed_contact1, _g_STContactSensorArr.element[bedRoomDoor_STContactSensor]);
				assign_STSwitch_rec(LightOffWhenClosed_switch1, _g_STSwitchArr.element[bedRoomBulb_STSwitch]);
			}

			if
			:: generatedEvent.EvtType == close -> LightOffWhenClosed_contactClosedEvtHandler(generatedEvent);
			:: else -> skip;
			fi
		}
		:: else -> skip;
		fi

		/* Handlers of LightFollowsMe */
		if
		:: _g_STMotionSensorArr.element[LightFollowsMe_motion1.gArrIndex].BroadcastChans[LightFollowsMe_motion1.BroadcastChanIndex] == true -> atomic {
			allEvtsHandled = false;
			/* Reset broadcast event indicator */
			 _g_STMotionSensorArr.element[LightFollowsMe_motion1.gArrIndex].BroadcastChans[LightFollowsMe_motion1.BroadcastChanIndex] = false

			/* Get latest event */
			getPrevStoredEvtIndex(_g_STMotionSensorArr.element[LightFollowsMe_motion1.gArrIndex].currEvtIndex, latestEvtIndex5);
			assign_STEvent_rec(generatedEvent, _g_STMotionSensorArr.element[LightFollowsMe_motion1.gArrIndex].events.element[latestEvtIndex5]);

			/* Fetch current data of global variables */
			d_step {
				assign_STMotionSensor_rec(LightFollowsMe_motion1, _g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor]);
				assign_STSwitch_rec(LightFollowsMe_switches.element[0], _g_STSwitchArr.element[livingRoomBulb_STSwitch]);
			}

			if
			:: true -> LightFollowsMe_motionEvtHandler(generatedEvent);
			:: else -> skip;
			fi
		}
		:: else -> skip;
		fi

		if
		:: allEvtsHandled == false -> {
			if
			:: STCurrentSystemTime >= MAX_SYSTEM_TIME -> assert(0);
			:: else -> skip;
			fi

			if
			:: systemTimeIncrementNeeded == true -> STCurrentSystemTime++;
			:: else -> skip;
			fi
			goto loc_StartOfEvtHandlers;
		}
		:: !(allEvtsHandled == false) -> eventProcessed = true;
		fi
	}
}
/*************** End of events generator *********************/

init {
	int gDeviceId;

	atomic {
		InitializeLocation();

		doorLock_STLock = _g_STLockArr.length;
		_g_STLockArr.element[doorLock_STLock].id = gDeviceId;
		_g_STLockArr.element[doorLock_STLock].gArrIndex = doorLock_STLock;
		_g_STLockArr.element[doorLock_STLock].NumSubscribers = 0;
		_g_STLockArr.element[doorLock_STLock].events.length = MAX_STORED_EVENTS;
		_g_STLockArr.element[doorLock_STLock].states.length = MAX_STORED_EVENTS;
		_g_STLockArr.element[doorLock_STLock].isAlive = 1;
		_g_STLockArr.element[doorLock_STLock].isOnline = 1;
		_g_STLockArr.element[doorLock_STLock].currentLock = LOCKED;
		_g_STLockArr.element[doorLock_STLock].lockState.value = LOCKED;
		_g_STLockArr.length++;
		gDeviceId++;
		frontDoorSensor_STMotionSensor = _g_STMotionSensorArr.length;
		_g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor].id = gDeviceId;
		_g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor].gArrIndex = frontDoorSensor_STMotionSensor;
		_g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor].NumSubscribers = 0;
		_g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor].events.length = MAX_STORED_EVENTS;
		_g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor].states.length = MAX_STORED_EVENTS;
		_g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor].isAlive = 1;
		_g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor].isOnline = 1;
		_g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor].currentMotion = INACTIVE;
		_g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor].motionState.value = INACTIVE;
		_g_STMotionSensorArr.length++;
		gDeviceId++;
		livingRoomBulb_STSwitch = _g_STSwitchArr.length;
		_g_STSwitchArr.element[livingRoomBulb_STSwitch].id = gDeviceId;
		_g_STSwitchArr.element[livingRoomBulb_STSwitch].gArrIndex = livingRoomBulb_STSwitch;
		_g_STSwitchArr.element[livingRoomBulb_STSwitch].NumSubscribers = 0;
		_g_STSwitchArr.element[livingRoomBulb_STSwitch].events.length = MAX_STORED_EVENTS;
		_g_STSwitchArr.element[livingRoomBulb_STSwitch].states.length = MAX_STORED_EVENTS;
		_g_STSwitchArr.element[livingRoomBulb_STSwitch].isAlive = 1;
		_g_STSwitchArr.element[livingRoomBulb_STSwitch].isOnline = 1;
		_g_STSwitchArr.element[livingRoomBulb_STSwitch].currentSwitch = OFF;
		_g_STSwitchArr.element[livingRoomBulb_STSwitch].switchState.value = OFF;
		_g_STSwitchArr.length++;
		gDeviceId++;
		bedRoomBulb_STSwitch = _g_STSwitchArr.length;
		_g_STSwitchArr.element[bedRoomBulb_STSwitch].id = gDeviceId;
		_g_STSwitchArr.element[bedRoomBulb_STSwitch].gArrIndex = bedRoomBulb_STSwitch;
		_g_STSwitchArr.element[bedRoomBulb_STSwitch].NumSubscribers = 0;
		_g_STSwitchArr.element[bedRoomBulb_STSwitch].events.length = MAX_STORED_EVENTS;
		_g_STSwitchArr.element[bedRoomBulb_STSwitch].states.length = MAX_STORED_EVENTS;
		_g_STSwitchArr.element[bedRoomBulb_STSwitch].isAlive = 1;
		_g_STSwitchArr.element[bedRoomBulb_STSwitch].isOnline = 1;
		_g_STSwitchArr.element[bedRoomBulb_STSwitch].currentSwitch = OFF;
		_g_STSwitchArr.element[bedRoomBulb_STSwitch].switchState.value = OFF;
		_g_STSwitchArr.length++;
		gDeviceId++;
		livingRoomSensor_STMotionSensor = _g_STMotionSensorArr.length;
		_g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor].id = gDeviceId;
		_g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor].gArrIndex = livingRoomSensor_STMotionSensor;
		_g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor].NumSubscribers = 0;
		_g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor].events.length = MAX_STORED_EVENTS;
		_g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor].states.length = MAX_STORED_EVENTS;
		_g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor].isAlive = 1;
		_g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor].isOnline = 1;
		_g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor].currentMotion = INACTIVE;
		_g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor].motionState.value = INACTIVE;
		_g_STMotionSensorArr.length++;
		gDeviceId++;
		bedRoomSensor_STMotionSensor = _g_STMotionSensorArr.length;
		_g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor].id = gDeviceId;
		_g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor].gArrIndex = bedRoomSensor_STMotionSensor;
		_g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor].NumSubscribers = 0;
		_g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor].events.length = MAX_STORED_EVENTS;
		_g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor].states.length = MAX_STORED_EVENTS;
		_g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor].isAlive = 1;
		_g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor].isOnline = 1;
		_g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor].currentMotion = INACTIVE;
		_g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor].motionState.value = INACTIVE;
		_g_STMotionSensorArr.length++;
		gDeviceId++;
		bedRoomDoor_STContactSensor = _g_STContactSensorArr.length;
		_g_STContactSensorArr.element[bedRoomDoor_STContactSensor].id = gDeviceId;
		_g_STContactSensorArr.element[bedRoomDoor_STContactSensor].gArrIndex = bedRoomDoor_STContactSensor;
		_g_STContactSensorArr.element[bedRoomDoor_STContactSensor].NumSubscribers = 0;
		_g_STContactSensorArr.element[bedRoomDoor_STContactSensor].events.length = MAX_STORED_EVENTS;
		_g_STContactSensorArr.element[bedRoomDoor_STContactSensor].states.length = MAX_STORED_EVENTS;
		_g_STContactSensorArr.element[bedRoomDoor_STContactSensor].isAlive = 1;
		_g_STContactSensorArr.element[bedRoomDoor_STContactSensor].isOnline = 1;
		_g_STContactSensorArr.element[bedRoomDoor_STContactSensor].currentContact = CLOSED;
		_g_STContactSensorArr.element[bedRoomDoor_STContactSensor].contactState.value = CLOSED;
		_g_STContactSensorArr.length++;
		gDeviceId++;

		/* Initialization for UnlockDoor */
		UnlockDoor_locks.length = 1;
		assign_STLock_rec(UnlockDoor_locks.element[0], _g_STLockArr.element[doorLock_STLock]);
		/* Broadcast channel index of location assignment */
		UnlockDoor_location = location.NumSubscribers;
		location.NumSubscribers++;
		/* Other input info assignment */

		/* Initialization for GoodNight */
		GoodNight_motionSensors.length = 3;
		assign_STMotionSensor_rec(GoodNight_motionSensors.element[0], _g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor]);
		GoodNight_motionSensors.element[0].BroadcastChanIndex = _g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor].NumSubscribers;
		_g_STMotionSensorArr.element[frontDoorSensor_STMotionSensor].NumSubscribers++;
		assign_STMotionSensor_rec(GoodNight_motionSensors.element[1], _g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor]);
		GoodNight_motionSensors.element[1].BroadcastChanIndex = _g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor].NumSubscribers;
		_g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor].NumSubscribers++;
		assign_STMotionSensor_rec(GoodNight_motionSensors.element[2], _g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor]);
		GoodNight_motionSensors.element[2].BroadcastChanIndex = _g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor].NumSubscribers;
		_g_STMotionSensorArr.element[bedRoomSensor_STMotionSensor].NumSubscribers++;
		GoodNight_switches.length = 2;
		assign_STSwitch_rec(GoodNight_switches.element[0], _g_STSwitchArr.element[livingRoomBulb_STSwitch]);
		GoodNight_switches.element[0].BroadcastChanIndex = _g_STSwitchArr.element[livingRoomBulb_STSwitch].NumSubscribers;
		_g_STSwitchArr.element[livingRoomBulb_STSwitch].NumSubscribers++;
		assign_STSwitch_rec(GoodNight_switches.element[1], _g_STSwitchArr.element[bedRoomBulb_STSwitch]);
		GoodNight_switches.element[1].BroadcastChanIndex = _g_STSwitchArr.element[bedRoomBulb_STSwitch].NumSubscribers;
		_g_STSwitchArr.element[bedRoomBulb_STSwitch].NumSubscribers++;
		/* Broadcast channel index of location assignment */
		GoodNight_location = location.NumSubscribers;
		location.NumSubscribers++;
		/* Other input info assignment */
		GoodNight_minutes = 30;
		GoodNight_newMode = 1402;
		GoodNight_sendPushMessage = 1501;

		/* Initialization for LightOffWhenClosed */
		assign_STContactSensor_rec(LightOffWhenClosed_contact1, _g_STContactSensorArr.element[bedRoomDoor_STContactSensor]);
		LightOffWhenClosed_contact1.BroadcastChanIndex = _g_STContactSensorArr.element[bedRoomDoor_STContactSensor].NumSubscribers;
		_g_STContactSensorArr.element[bedRoomDoor_STContactSensor].NumSubscribers++;
		assign_STSwitch_rec(LightOffWhenClosed_switch1, _g_STSwitchArr.element[bedRoomBulb_STSwitch]);
		/* Other input info assignment */

		/* Initialization for LightFollowsMe */
		assign_STMotionSensor_rec(LightFollowsMe_motion1, _g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor]);
		LightFollowsMe_motion1.BroadcastChanIndex = _g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor].NumSubscribers;
		_g_STMotionSensorArr.element[livingRoomSensor_STMotionSensor].NumSubscribers++;
		LightFollowsMe_switches.length = 1;
		assign_STSwitch_rec(LightFollowsMe_switches.element[0], _g_STSwitchArr.element[livingRoomBulb_STSwitch]);
		/* Other input info assignment */
		LightFollowsMe_minutes1 = 10;

		/* Start all of the processes */
		run SmartThings();
	}
}
ltl p1 {[](location.mode != NIGHT
	|| _g_STLockArr.element[doorLock_STLock].currentLock!=UNLOCKED
	|| eventProcessed != true)}